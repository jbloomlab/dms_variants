
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dms_variants.globalepistasis &#8212; dms_variants 1.4.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for dms_variants.globalepistasis</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">=================</span>
<span class="sd">globalepistasis</span>
<span class="sd">=================</span>

<span class="sd">Implements global epistasis models that are based on (but extend in some</span>
<span class="sd">ways) those described in `Otwinoski et al (2018)`_.</span>
<span class="sd">See also `Sailer and Harms (2017)`_ and `Otwinoski (2018)`_.</span>

<span class="sd">.. contents:: Contents</span>
<span class="sd">   :local:</span>
<span class="sd">   :depth: 2</span>

<span class="sd">.. _global_epistasis_function:</span>

<span class="sd">Global epistasis function</span>
<span class="sd">---------------------------</span>

<span class="sd">The global epistasis function is defined as follows.</span>
<span class="sd">Let :math:`v` be a variant. We convert</span>
<span class="sd">:math:`v` into a binary representation with respect to some wildtype</span>
<span class="sd">sequence. This representation is a vector :math:`\mathbf{b}\left(v\right)`</span>
<span class="sd">with element :math:`b\left(v\right)_m` equal to 1 if the variant has mutation</span>
<span class="sd">:math:`m` and 0 otherwise, and :math:`m` ranging over all :math:`M` mutations</span>
<span class="sd">observed in the overall set of variants (so :math:`\mathbf{b}\left(v\right)`</span>
<span class="sd">is of length :math:`M`). Variants can be converted into this binary form</span>
<span class="sd">using `binarymap &lt;https://github.com/jbloomlab/binarymap&gt;`_.</span>

<span class="sd">We define a *latent effect* for each mutation :math:`m`, which we denote as</span>
<span class="sd">:math:`\beta_m`. The latent effects of mutations contribute additively to the</span>
<span class="sd">*latent phenotype*, and the latent phenotype of the wildtype sequence is</span>
<span class="sd">:math:`\beta_{\rm{wt}}`. So the *latent phenotype* of variant :math:`v` is:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: latent_phenotype</span>

<span class="sd">   \phi\left(v\right) = \beta_{\rm{wt}} +</span>
<span class="sd">                        \sum_{m=1}^M \beta_m b\left(v\right)_m.</span>

<span class="sd">The predicted *observed phenotype* :math:`p\left(v\right)` is a function of the</span>
<span class="sd">latent phenotype:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: observed_phenotype</span>

<span class="sd">   p\left(v\right) = g\left(\phi\left(v\right)\right)</span>

<span class="sd">where :math:`g` is the *global epistasis function*.</span>

<span class="sd">We define the following global epistasis functions:</span>

<span class="sd">.. _no_epistasis_function:</span>

<span class="sd">No epistasis function</span>
<span class="sd">+++++++++++++++++++++++</span>
<span class="sd">No epistasis, so the observed phenotype is just the latent phenotype:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: noepistasis</span>

<span class="sd">   g\left(x\right) = x.</span>

<span class="sd">This function is implemented as :class:`NoEpistasis`.</span>

<span class="sd">.. _monotonic_spline_epistasis_function:</span>

<span class="sd">Monotonic spline epistasis function</span>
<span class="sd">++++++++++++++++++++++++++++++++++++</span>
<span class="sd">This is the function used in `Otwinoski et al (2018)`_. It transforms</span>
<span class="sd">the latent phenotype to the observed phenotype using monotonic I-splines with</span>
<span class="sd">linear extrapolation outside the spline boundaries:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: monotonicspline</span>

<span class="sd">   g\left(x\right)</span>
<span class="sd">   =</span>
<span class="sd">   \begin{cases}</span>
<span class="sd">   c_{\alpha} + \sum_{m=1}^M \alpha_{m} I_m\left(x\right)</span>
<span class="sd">     &amp; \rm{if\;} L \le x \le U, \\</span>
<span class="sd">   c_{\alpha} + \sum_{m=1}^M \alpha_m</span>
<span class="sd">     \left[I_m\left(L\right) + \left(x - L\right)</span>
<span class="sd">           \left.\frac{\partial I_m\left(y\right)}</span>
<span class="sd">                      {\partial y}\right\rvert_{y=L}</span>
<span class="sd">     \right]</span>
<span class="sd">     &amp; \rm{if\;} x &lt; L, \\</span>
<span class="sd">   c_{\alpha} + \sum_{m=1}^M \alpha_m</span>
<span class="sd">     \left[I_m\left(U\right) + \left(x - U\right)</span>
<span class="sd">           \left.\frac{\partial I_m\left(y\right)}</span>
<span class="sd">                      {\partial y}\right\rvert_{y=U}</span>
<span class="sd">     \right]</span>
<span class="sd">     &amp; \rm{if\;} x &gt; U,</span>
<span class="sd">   \end{cases}</span>

<span class="sd">where :math:`c_{\alpha}` is an arbitrary number giving the *minimum*</span>
<span class="sd">observed phenotype, the :math:`\alpha_m` coefficients are all :math:`\ge 0`,</span>
<span class="sd">:math:`I_m` indicates a family of I-splines defined via</span>
<span class="sd">:class:`dms_variants.ispline.Isplines_total`, and :math:`L` and :math:`U` are</span>
<span class="sd">the lower and upper bounds on the regions over which the I-splines are defined.</span>
<span class="sd">Note how when :math:`x` is outside the range of the I-splines, we linearly</span>
<span class="sd">extrapolate :math:`g` from its range boundaries to calculate.</span>

<span class="sd">This function is implemented as :class:`MonotonicSplineEpistasis`. By default,</span>
<span class="sd">the I-splines are of order 3 and are defined on a mesh of four evenly spaced</span>
<span class="sd">points such that the total number of I-splines is :math:`M=5` (although these</span>
<span class="sd">options can be adjusted when initializing a :class:`MonotonicSplineEpistasis`</span>
<span class="sd">model).</span>

<span class="sd">The latent effects are scaled so that their mean absolute value is one,</span>
<span class="sd">and the latent phenotype of the wildtype is set to zero.</span>

<span class="sd">.. _multi_latent:</span>

<span class="sd">Multiple latent phenotypes</span>
<span class="sd">+++++++++++++++++++++++++++</span>
<span class="sd">Although this package allows multiple latent phenotypes, we do **not**</span>
<span class="sd">recommend using them as the models generally do not seem to converge</span>
<span class="sd">in fitting in a useful way with multiple latent phenotypes.</span>

<span class="sd">Equations :eq:`latent_phenotype` and :eq:`observed_phenotype` can be</span>
<span class="sd">generalized to the case where multiple latent phenotypes contribute</span>
<span class="sd">to the observed phenotype. Specifically, let there be</span>
<span class="sd">:math:`k = 1, \ldots, K` different latent phenotypes, and let</span>
<span class="sd">:math:`\beta_m^k` denote the effect of mutation :math:`m` on latent phenotype</span>
<span class="sd">:math:`k`. Then we generalize Equation :eq:`latent_phenotype` to</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: latent_phenotype_multi</span>

<span class="sd">   \phi_k\left(v\right) = \beta_{\rm{wt}}^k +</span>
<span class="sd">                          \sum_{m=1}^M \beta_m^k b\left(v\right)_m,</span>

<span class="sd">and Equation :eq:`observed_phenotype` to</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: observed_phenotype_multi</span>

<span class="sd">   p\left(v\right) = \sum_{k=1}^K g_k\left(\phi_k\left(v\right)\right),</span>

<span class="sd">where :math:`\phi_k\left(v\right)` is the :math:`k`-th latent phenotype of</span>
<span class="sd">variant :math:`v`, and :math:`g_k` is the :math:`k`-th global epistasis</span>
<span class="sd">function.</span>

<span class="sd">Note that it does **not** make sense to fit multiple latent phenotypes</span>
<span class="sd">to a non-epistatic model as a linear combination of linear effects</span>
<span class="sd">reduces to a simple linear model (in other words, a multi-latent</span>
<span class="sd">phenotype non-epistatic model is no differen than a one-latent</span>
<span class="sd">phenotype non-epistatic model).</span>

<span class="sd">.. _likelihood_calculation:</span>

<span class="sd">Likelihood calculation</span>
<span class="sd">---------------------------------------</span>
<span class="sd">We defined a *likelihood* capturing how well the model describes the</span>
<span class="sd">actual data, and then fit the models by finding the parameters that</span>
<span class="sd">maximize this likelihood. This means that different epistasis functions</span>
<span class="sd">(as described in `Global epistasis function`_) can be compared via</span>
<span class="sd">their likelihoods after correcting for the number of parameters</span>
<span class="sd">(e.g. by `AIC &lt;https://en.wikipedia.org/wiki/Akaike_information_criterion&gt;`_).</span>

<span class="sd">We consider several different forms for calculating the likelihood.</span>
<span class="sd">Note that epistasis functions can only be compared within the same form of</span>
<span class="sd">the likelihood on the same dataset--you **cannot** compare likelihoods</span>
<span class="sd">calculated using different methods, or on different datasets.</span>

<span class="sd">.. _gaussian_likelihood:</span>

<span class="sd">Gaussian likelihood</span>
<span class="sd">++++++++++++++++++++</span>
<span class="sd">This is the form of the likelihood used in `Otwinoski et al (2018)`_. It is</span>
<span class="sd">most appropriate when we have functional scores for variants along with</span>
<span class="sd">good estimates of normally distributed errors on these functional scores.</span>

<span class="sd">For each variant :math:`v`, we have an experimentally measured functional</span>
<span class="sd">score :math:`y_v` and optionally an estimate of the error (variance)</span>
<span class="sd">:math:`\sigma^2_{y_v}` in this functional score measurement. If no error</span>
<span class="sd">estimates are available, then we set :math:`\sigma^2_{y_v} = 0`.</span>

<span class="sd">The goal of the fitting is to parameterize the model so the observed phenotype</span>
<span class="sd">:math:`p\left(v\right)` predicted by the model is as close as possible to the</span>
<span class="sd">measured functional score :math:`y_v`. Following `Otwinoski et al (2018)`_,</span>
<span class="sd">we assume the likelihood of measuring a functional score :math:`y_v` is</span>
<span class="sd">normally distributed around the model prediction :math:`p\left(v\right)`</span>
<span class="sd">with variance :math:`\sigma^2_{y_v} + \sigma^2_{\rm{HOC}}`, where</span>
<span class="sd">:math:`\sigma^2_{\rm{HOC}}` is the un-modeled *house-of-cards epistasis*</span>
<span class="sd">(although in practice it could also represent experimental noise not</span>
<span class="sd">capture in the variance estimates). So the overall log likelihood of</span>
<span class="sd">the model is</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: loglik_gaussian</span>

<span class="sd">   \mathcal{L} = \sum_{v=1}^V \ln\left[N\left(y_v \mid p\left(v\right),</span>
<span class="sd">                 \sigma^2_{y_v} + \sigma^2_{\rm{HOC}}\right)\right]</span>

<span class="sd">where :math:`V` is the number of variants and :math:`N` is the normal</span>
<span class="sd">distribution defined by</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: normaldist</span>

<span class="sd">   N\left(y \mid \mu, \sigma^2\right) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp</span>
<span class="sd">                    \left(-\frac{\left(y - \mu\right)^2}{2 \sigma^2}\right).</span>

<span class="sd">This likelihood calculation is implemented as :class:`GaussianLikelihood`.</span>

<span class="sd">.. _cauchy_likelihood:</span>

<span class="sd">Cauchy likelihood</span>
<span class="sd">+++++++++++++++++++</span>
<span class="sd">This form of the likelihood assumes that the difference between the</span>
<span class="sd">measured functional scores and the model&#39;s observed phenotypes follows a</span>
<span class="sd">`Cauchy distribution &lt;https://en.wikipedia.org/wiki/Cauchy_distribution&gt;`_.</span>

<span class="sd">A potential advantage over the :ref:`gaussian_likelihood` is the</span>
<span class="sd">`fatter tails &lt;https://en.wikipedia.org/wiki/Fat-tailed_distribution&gt;`_</span>
<span class="sd">of the Cauchy distribution relative to the Gaussian distribution.</span>
<span class="sd">This could be advantageous if some measurements are very large outliers</span>
<span class="sd">(either due to un-modeled epistasis or experimental factors such as</span>
<span class="sd">mis-calling of variant sequences) in ways that are not</span>
<span class="sd">capture in the functional score variance estimates :math:`\sigma^2_{y_v}`.</span>
<span class="sd">Such outlier measurements will have less influence on the overall model</span>
<span class="sd">fit for the Cauchy likelihood relative to the :ref:`gaussian_likelihood`.</span>

<span class="sd">Specifically, we compute the overall log likelihood as</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: loglik_cauchy</span>

<span class="sd">   \mathcal{L} = -\sum_{v=1}^V</span>
<span class="sd">                 \ln\left[\pi \sqrt{\gamma^2 + \sigma^2_{y_v}}</span>
<span class="sd">                          \left(1 + \frac{\left[y_v - p\left(v\right)\right]^2}</span>
<span class="sd">                                         {\gamma^2 + \sigma^2_{y_v}}</span>
<span class="sd">                          \right)</span>
<span class="sd">                     \right]</span>

<span class="sd">where :math:`\gamma` is the scale parameters, and the functional score</span>
<span class="sd">variance estimates :math:`\sigma^2_{y_v}` are incorporated in heuristic way</span>
<span class="sd">(with no real theoretical basis)</span>
<span class="sd">that qualitatively captures the fact that larger variance estimates give a</span>
<span class="sd">broader distribution. If variance estimates are not available then</span>
<span class="sd">:math:`\sigma^2_{y_v}` is set to zero.</span>

<span class="sd">This likelihood calculation is implemented as :class:`CauchyLikelihood`.</span>

<span class="sd">.. _bottleneck_likelihood:</span>

<span class="sd">Bottleneck likelihood</span>
<span class="sd">++++++++++++++++++++++</span>
<span class="sd">This form of the likelihood is appropriate when most noise in the experiment</span>
<span class="sd">comes from a bottleneck when passaging the library from the pre-selection to</span>
<span class="sd">post-selection condition. This will be the case when the total pre- and post-</span>
<span class="sd">selection sequencing depths greatly exceed the number of variants</span>
<span class="sd">that were physically passaged from the pre-selection library to the post-</span>
<span class="sd">selection condition. At least in Bloom lab viral deep mutational scanning</span>
<span class="sd">experiments, this situation is quite common.</span>

<span class="sd">A full derivation of the log likelihood in this situation is given in</span>
<span class="sd">:doc:`bottleneck_likelihood`. As explained in those calculations, the</span>
<span class="sd">likelihood is computed from the experimental observables</span>
<span class="sd">:math:`f_v^{\text{pre}}` and :math:`f_v^{\text{post}}`, which represent</span>
<span class="sd">the pre- and post-selection frequencies of variant :math:`v`. They are</span>
<span class="sd">computed from the pre- and post-selection counts :math:`n_v^{\text{pre}}`</span>
<span class="sd">and :math:`n_v^{\text{post}}` of the variants as</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: f_v_pre_post</span>

<span class="sd">   f_v^{\text{pre}}</span>
<span class="sd">   &amp;=&amp; \frac{n_v^{\text{pre}} + C}</span>
<span class="sd">            {\sum_{v&#39;=1}^V \left(n_{v&#39;}^{\text{pre}} + C \right)} \\</span>
<span class="sd">   f_v^{\text{post}}</span>
<span class="sd">   &amp;=&amp; \frac{n_v^{\text{post}} + C}</span>
<span class="sd">            {\sum_{v&#39;=1}^V \left(n_{v&#39;}^{\text{post}} + C \right)}</span>

<span class="sd">where :math:`C` is a pseudocount which by default is 0.5.</span>

<span class="sd">Using the bottleneck likelihood also requires an estimation of the experimental</span>
<span class="sd">bottleneck :math:`N_{\rm{bottle}}` when passaging the library from the pre-</span>
<span class="sd">to post-selection conditions. A smaller bottleneck will correspond to more</span>
<span class="sd">&quot;noise&quot; in the experiment, since random bottlenecking changes the frequencies</span>
<span class="sd">of variants unpredictably. You can either estimate :math:`N_{\rm{bottle}}`</span>
<span class="sd">experimentally or from fluctuations in the relative frequencies of</span>
<span class="sd">wildtype or synonymous variants, such as via</span>
<span class="sd">:func:`dms_variants.bottlenecks.estimateBottleneck`.</span>

<span class="sd">Given these experimentally measured parameters, the overall log likelihood is:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: loglik_bottleneck</span>

<span class="sd">   \mathcal{L}</span>
<span class="sd">   =</span>
<span class="sd">   \sum_{v=1}^V</span>
<span class="sd">   \left[ n_v^{\rm{bottle}} \ln\left(N_{\rm{bottle}} f_v^{\text{pre}}\right)</span>
<span class="sd">          - \ln \Gamma \left(n_v^{\rm{bottle}} + 1\right)</span>
<span class="sd">        \right] - N_{\rm{bottle}}</span>

<span class="sd">where :math:`\Gamma` is the</span>
<span class="sd">`gamma function &lt;https://en.wikipedia.org/wiki/Gamma_function&gt;`_</span>
<span class="sd">and :math:`n_v^{\rm{bottle}}` is the estimated number of copies of variant</span>
<span class="sd">:math:`v` that made it through the bottleneck, which is defined in terms</span>
<span class="sd">of the phenotype :math:`p\left(v\right)` as</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: n_v_bottle</span>

<span class="sd">   n_v^{\rm{bottle}}</span>
<span class="sd">   =</span>
<span class="sd">   \frac{f_v^{\rm{post}} N_{\rm{bottle}}</span>
<span class="sd">         \sum_{v&#39;=1}^V f_{v&#39;}^{\text{pre}} 2^{p\left(v&#39;\right)}}</span>
<span class="sd">        {2^{p\left(v\right)}}.</span>

<span class="sd">The free parameters are therefore the :math:`p\left(v\right)` values</span>
<span class="sd">(the :math:`n_v^{\rm{bottle}}` values are hidden variables that are</span>
<span class="sd">not explicitly estimated). Note that Eq. :eq:`n_v_bottle`</span>
<span class="sd">uses an exponent base of 2, but it can be set to arbitrary positive values</span>
<span class="sd">in the actual implementation.</span>

<span class="sd">After fitting the observed phenotypes, the parameters are re-scaled</span>
<span class="sd">so that the observed phenotype of wildtype is zero</span>
<span class="sd">(i.e., :math:`p\left(\rm{wt}\right) = 0`).</span>

<span class="sd">This likelihood calculation is implemented as :class:`BottleneckLikelihood`.</span>

<span class="sd">The model classes</span>
<span class="sd">------------------</span>
<span class="sd">The epistasis models are defined in a set of classes. All these classes</span>
<span class="sd">inherit their main functionality from the :class:`AbstractEpistasis`</span>
<span class="sd">abstract base class.</span>

<span class="sd">There are subclasses of :class:`AbstractEpistasis` that implement the</span>
<span class="sd">global epistasis functions and likelihood calculation methods. Specifically,</span>
<span class="sd">the following classes implement a :ref:`global_epistasis_function`:</span>

<span class="sd">  - :class:`NoEpistasis`</span>
<span class="sd">  - :class:`MonotonicSplineEpistasis`</span>

<span class="sd">and the following classes each implement a :ref:`likelihood_calculation`:</span>
<span class="sd">  - :class:`GaussianLikelihood`</span>
<span class="sd">  - :class:`CauchyLikelihood`</span>
<span class="sd">  - :class:`BottleneckLikelihood`</span>

<span class="sd">However, those classes can still not be directly instantianted, as a fully</span>
<span class="sd">concrete model subclass must have **both** a global epistasis function and</span>
<span class="sd">a likelihood calculation method.</span>
<span class="sd">The following classes implement both, and so can be directly instantiated</span>
<span class="sd">for use in analyses:</span>

<span class="sd">  - :class:`NoEpistasisGaussianLikelihood`</span>
<span class="sd">  - :class:`NoEpistasisCauchyLikelihood`</span>
<span class="sd">  - :class:`NoEpistasisBottleneckLikelihood`</span>
<span class="sd">  - :class:`MonotonicSplineEpistasisGaussianLikelihood`</span>
<span class="sd">  - :class:`MonotonicSplineEpistasisCauchyLikelihood`</span>
<span class="sd">  - :class:`MonotonicSplineEpistasisBottleneckLikelihood`</span>

<span class="sd">Details of fitting</span>
<span class="sd">-------------------------</span>

<span class="sd">.. _fitting_workflow:</span>

<span class="sd">Fitting workflow</span>
<span class="sd">+++++++++++++++++</span>
<span class="sd">The fitting workflow for a single latent phenotype is similar to that described</span>
<span class="sd">in `Otwinoski et al (2018)`_:</span>

<span class="sd"> 1. The latent effects are fit under an additive (non-epistatic) model</span>
<span class="sd">    using least squares. The residuals from this fit are then used to</span>
<span class="sd">    estimate :math:`\sigma^2_{\rm{HOC}}` for :ref:`gaussian_likelihood`,</span>
<span class="sd">    or :math:`\gamma^2` for :ref:`cauchy_likelihood`.</span>
<span class="sd"> 2. If there are any parameters in the epistasis function, they are set</span>
<span class="sd">    to reasonable initial values. For :class:`MonotonicSplineEpistasis`</span>
<span class="sd">    this involves setting the mesh to go from 0 to 1, scaling the latent</span>
<span class="sd">    effects so that the latent phenotypes range from 0 to 1, setting</span>
<span class="sd">    :math:`c_{\alpha}` to the minimum functional score and setting the</span>
<span class="sd">    weights :math:`\alpha_m` to equal values such that the max of the</span>
<span class="sd">    epistasis function is the same as the max functional score.</span>
<span class="sd"> 3. The overall model is fit by maximum likelihood.</span>
<span class="sd"> 4. For :class:`MonotonicSplineEpistasis`, the latent effects and wildtype</span>
<span class="sd">    latent phenotype are rescaled so that the mean absolute value latent</span>
<span class="sd">    effect is one and the wildtype latent phenotype is zero.</span>


<span class="sd">.. _fitting_multi_latent:</span>

<span class="sd">Fitting multiple latent phenotypes</span>
<span class="sd">++++++++++++++++++++++++++++++++++</span>
<span class="sd">When there are multiple latent phenotypes (see :ref:`multi_latent`), the</span>
<span class="sd">fitting workflow changes. To fit a model with :math:`K &gt; 1` latent phenotypes,</span>
<span class="sd">first fit a model of the same type to the same data with :math:`K - 1` latent</span>
<span class="sd">phenotype. The values from that fit for the first :math:`K - 1` latent</span>
<span class="sd">phenotypes are used to initialize all parameters relevant to those first</span>
<span class="sd">:math:`K - 1` latent phenotypes and the associated global epistasis</span>
<span class="sd">functions and likelihood calculations.</span>

<span class="sd">Then parameters relevant to latent phenotype :math:`K` are set so the initial</span>
<span class="sd">contribution of this phenotype to the overall observed phenotype is zero.</span>
<span class="sd">Specifically the latent effects :math:`\beta_m^K` for phenotype :math:`K` are</span>
<span class="sd">all set to zero and :math:`\beta_{\rm{wt}}^K` is chosen so that</span>
<span class="sd">:math:`0 = g_K \left(\beta_{\rm{wt}}^K\right)`. For a</span>
<span class="sd">:class:`MonotonicSplineEpistasis` model, initial parameters for :math:`g_K` are</span>
<span class="sd">chosen so that over the mesh, :math:`g_K` spans +/- the absolute value of</span>
<span class="sd">the largest residual of the model with :math:`K - 1` latent phenotypes.</span>

<span class="sd">After initializing the paramters in this way, the entire model (all latent</span>
<span class="sd">phenotypes) is fit by maximum likelihood.</span>

<span class="sd">Conveniently fitting and comparing several models</span>
<span class="sd">+++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="sd">To conveniently fit and compare several models, use :func:`fit_models`.</span>
<span class="sd">This is especially useful when you are including models with multiple</span>
<span class="sd">latent phenotypes.</span>

<span class="sd">Vector representation of :math:`\beta_{\rm{wt}}`</span>
<span class="sd">+++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="sd">For the purposes of the optimization (and in the equations below), we change</span>
<span class="sd">how :math:`\beta_{\rm{wt}}` is represented to simplify the calculations.</span>
<span class="sd">Specifically, to the binary encoding :math:`\mathbf{b}\left(v\right)` of</span>
<span class="sd">each variant, we append a 1 so that the encodings are now of length</span>
<span class="sd">:math:`M + 1`. We then define :math:`\beta_{M + 1} = \beta_{\rm{wt}}`.</span>
<span class="sd">Then Eq. :eq:`latent_phenotype` can be rewritten as</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: latent_phenotype_wt_vec</span>

<span class="sd">   \phi\left(v\right) = \sum_{m=1}^{M+1} \beta_m b\left(v\right)_m</span>

<span class="sd">enabling :math:`\beta_{\rm{wt}}` to just be handled like the other</span>
<span class="sd">:math:`\beta_m` parameters.</span>

<span class="sd">Optimization</span>
<span class="sd">++++++++++++</span>
<span class="sd">The optimization is performed by :meth:`AbstractEpistasis.fit`.</span>
<span class="sd">There are several options to that method about how to do the optimization;</span>
<span class="sd">by default it uses a L-BFGS-B algorithm with exact gradients</span>
<span class="sd">calculated as below.</span>

<span class="sd">Gradients used in optimization</span>
<span class="sd">+++++++++++++++++++++++++++++++</span>

<span class="sd">For the optimization, we use the following gradients:</span>

<span class="sd">Gradient of latent phenotype with respect to latent effects:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dlatent_phenotype_dlatent_effect</span>

<span class="sd">   \frac{\partial \phi_j\left(v\right)}{\partial \beta_m^k} =</span>
<span class="sd">   \begin{cases}</span>
<span class="sd">   b\left(v_m\right) &amp; \rm{if\;} j = k, \\</span>
<span class="sd">   0 &amp; \rm{otherwise.} \\</span>
<span class="sd">   \end{cases}</span>

<span class="sd">Gradient of observed phenotype with respect to latent phenotypes:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dobserved_phenotype_dlatent_effect</span>

<span class="sd">   \frac{\partial p\left(v\right)}{\partial \beta_m^k}</span>
<span class="sd">   &amp;=&amp; \left.\frac{\partial g_k\left(x\right)}{\partial x}</span>
<span class="sd">       \right\rvert_{x = \phi_k\left(v\right)} \times</span>
<span class="sd">       \frac{\partial \phi_k\left(v\right)}{\partial \beta_m^k} \\</span>
<span class="sd">   &amp;=&amp; \left.\frac{\partial g_k\left(x\right)}{\partial x}</span>
<span class="sd">       \right\rvert_{x = \phi_k\left(v\right)} \times b\left(v_m\right)</span>

<span class="sd">Derivative of the likelihood with respect to latent effects:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dloglik_dlatent_effect</span>

<span class="sd">   \frac{\partial \mathcal{L}}{\partial \beta_m^k}</span>
<span class="sd">   = \sum_{v=1}^V \frac{\mathcal{L}}</span>
<span class="sd">                       {\partial p\left(v\right)} \times</span>
<span class="sd">                  \frac{\partial p\left(v\right)}{\partial \beta_m^k}.</span>

<span class="sd">Derivative of :ref:`gaussian_likelihood` (Eq. :eq:`loglik_gaussian`) with</span>
<span class="sd">respect to observed phenotype:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dloglik_gaussian_dobserved_phenotype</span>

<span class="sd">   \frac{\partial \mathcal{L}}{\partial p\left(v\right)}</span>
<span class="sd">   = \frac{y_v - p\left(v\right)}</span>
<span class="sd">          {\sigma_{y_v}^2 + \sigma^2_{\rm{HOC}}}.</span>

<span class="sd">Derivative of :ref:`gaussian_likelihood` (Eq. :eq:`loglik_gaussian`) with</span>
<span class="sd">respect to house-of-cards epistasis:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dloglik_gaussian_depistasis_HOC</span>

<span class="sd">   \frac{\partial \mathcal{L}}{\partial \sigma^2_{\rm{HOC}}} = \sum_{v=1}^V</span>
<span class="sd">   \frac{1}{2} \left[\left(\frac{\partial \mathcal{L}}</span>
<span class="sd">                                {\partial p\left(v\right)}\right)^2</span>
<span class="sd">                     - \frac{1}{\sigma_{y_v}^2 + \sigma_{\rm{HOC}}^2} \right].</span>

<span class="sd">Derivative of :ref:`cauchy_likelihood` (Eq. :eq:`loglik_cauchy`) with</span>
<span class="sd">respect to observed phenotype:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dloglik_cauchy_dobserved_phenotype</span>

<span class="sd">   \frac{\partial \mathcal{L}}{\partial p\left(v\right)}</span>
<span class="sd">   =</span>
<span class="sd">   \frac{2\left[y_v - p\left(v\right)\right]}</span>
<span class="sd">        {\gamma^2 + \sigma^2_{y_v} +</span>
<span class="sd">         \left[y_v - p\left(v\right)\right]^2}.</span>

<span class="sd">Derivative of :ref:`cauchy_likelihood` (Eq. :eq:`loglik_cauchy`) with</span>
<span class="sd">respect to scale parameter:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dloglik_cauchy_dscale_parameter</span>

<span class="sd">   \frac{\partial \mathcal{L}}{\partial \gamma}</span>
<span class="sd">   =</span>
<span class="sd">   \sum_{v=1}^{V} \frac{\gamma\left(\left[y_v - p\left(v\right)\right]^2 -</span>
<span class="sd">                                    \gamma^2 - \sigma^2_{y_v}</span>
<span class="sd">                              \right)}</span>
<span class="sd">                       {\left(\gamma^2 + \sigma^2_{y_v}\right)</span>
<span class="sd">                        \left(\gamma^2 + \sigma^2_{y_v} +</span>
<span class="sd">                              \left[y_v - p\left(v\right)\right]^2\right)</span>
<span class="sd">                        }</span>

<span class="sd">Derivative of :ref:`bottleneck_likelihood` with respect to</span>
<span class="sd">:math:`p\left(v\right)`:</span>

<span class="sd">.. math::</span>

<span class="sd">   \frac{\partial n_v^{\text{bottle}}}</span>
<span class="sd">        {\partial p\left(v&#39;\right)}</span>
<span class="sd">   &amp;=&amp;</span>
<span class="sd">   \begin{cases}</span>
<span class="sd">   \frac{\left(\ln 2\right) f_v^{\text{post}} N_{\text{bottle}}</span>
<span class="sd">         f_{v}^{\text{pre}} 2^{p\left(v\right)}}</span>
<span class="sd">        {2^{p\left(v\right)}}</span>
<span class="sd">   - \left(\ln 2\right) n_v^{\text{bottle}}</span>
<span class="sd">   &amp; \rm{if\;} v = v&#39;, \\</span>
<span class="sd">   \frac{\left(\ln 2\right) f_v^{\text{post}} N_{\text{bottle}}</span>
<span class="sd">         f_{v&#39;}^{\text{pre}} 2^{p\left(v&#39;\right)}}</span>
<span class="sd">        {2^{p\left(v\right)}}</span>
<span class="sd">   &amp; \text{otherwise}</span>
<span class="sd">   \end{cases} \\</span>
<span class="sd">   &amp;=&amp;</span>
<span class="sd">   \frac{\left(\ln 2\right) f_v^{\text{post}} N_{\text{bottle}}</span>
<span class="sd">         f_{v&#39;}^{\text{pre}} 2^{p\left(v&#39;\right)}}</span>
<span class="sd">        {2^{p\left(v\right)}}</span>
<span class="sd">   - \delta_{v,v&#39;} \left(\ln 2\right) n_{v&#39;}^{\text{bottle}}</span>


<span class="sd">.. math::</span>
<span class="sd">   :label: dloglik_bottleneck_dobserved_phenotype</span>

<span class="sd">   \frac{\partial \mathcal{L}}</span>
<span class="sd">        {\partial p\left(v&#39;\right)}</span>
<span class="sd">   &amp;=&amp;</span>
<span class="sd">   \sum_{v=1}^V</span>
<span class="sd">   \frac{\partial n_v^{\text{bottle}}}{\partial p\left(v&#39;\right)}</span>
<span class="sd">   \ln\left( N_{\text{bottle}} f_v^{\text{pre}} \right)</span>
<span class="sd">   -</span>
<span class="sd">   \frac{\partial n_v^{\text{bottle}}}{\partial p\left(v&#39;\right)}</span>
<span class="sd">   \psi_0\left(n_v^{\text{bottle}} + 1\right)</span>
<span class="sd">   \\</span>
<span class="sd">   &amp;=&amp;</span>
<span class="sd">   \left(\ln 2\right) f_{v&#39;}^{\text{pre}} 2^{p\left(v&#39;\right)}</span>
<span class="sd">   N_{\text{bottle}}</span>
<span class="sd">   \left(\sum_{v=1}^V</span>
<span class="sd">         \frac{f_v^{\text{post}}}</span>
<span class="sd">              {2^{p\left(v\right)}}</span>
<span class="sd">         \left[\ln\left(N_{\text{bottle}} f_v^{\text{pre}}\right) -</span>
<span class="sd">               \psi_0\left(n_v^{\text{bottle}} + 1\right)</span>
<span class="sd">               \right]</span>
<span class="sd">         \right)</span>
<span class="sd">   - \left(\ln 2\right) n_{v&#39;}^{\text{bottle}}</span>
<span class="sd">     \left[\ln\left(N_{\text{bottle}} f_{v&#39;}^{\text{pre}}\right) -</span>
<span class="sd">           \psi_0\left(n_{v&#39;}^{\text{bottle}} + 1\right)</span>
<span class="sd">           \right]</span>

<span class="sd">where :math:`\psi_0` is the</span>
<span class="sd">`digamma function &lt;https://en.wikipedia.org/wiki/Digamma_function&gt;`_.</span>

<span class="sd">Derivative of :ref:`monotonic_spline_epistasis_function` with respect to its</span>
<span class="sd">parameters:</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dspline_epistasis_dcalpha</span>

<span class="sd">   \frac{\partial g_k\left(x\right)}{\partial c_{\alpha}^k} = 1</span>

<span class="sd">.. math::</span>
<span class="sd">   :label: dspline_epistasis_dalpham</span>

<span class="sd">   \frac{\partial g_k\left(x\right)}{\partial \alpha^k_m}</span>
<span class="sd">   = I^k_m\left(x\right)</span>


<span class="sd">Detailed documentation of models</span>
<span class="sd">---------------------------------</span>

<span class="sd">.. _`Otwinoski et al (2018)`: https://www.pnas.org/content/115/32/E7550</span>
<span class="sd">.. _`Sailer and Harms (2017)`: https://www.genetics.org/content/205/3/1079</span>
<span class="sd">.. _`Otwinoski (2018)`: https://doi.org/10.1093/molbev/msy141</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>

<span class="kn">import</span> <span class="nn">dms_variants.ispline</span>
<span class="kn">import</span> <span class="nn">dms_variants.utils</span>


<div class="viewcode-block" id="EpistasisFittingError"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.EpistasisFittingError">[docs]</a><span class="k">class</span> <span class="nc">EpistasisFittingError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error fitting an epistasis model.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="EpistasisFittingWarning"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.EpistasisFittingWarning">[docs]</a><span class="k">class</span> <span class="nc">EpistasisFittingWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning when fitting epistasis model.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="AbstractEpistasis"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis">[docs]</a><span class="k">class</span> <span class="nc">AbstractEpistasis</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for epistasis models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binarymap : `BinaryMap &lt;https://github.com/jbloomlab/binarymap&gt;`_</span>
<span class="sd">        Contains the variants, their functional scores, and score variances.</span>
<span class="sd">    n_latent_phenotypes : int</span>
<span class="sd">        Number of distinct latent phenotypes. See :ref:`multi_latent`.</span>
<span class="sd">    model_one_less_latent : None or :class:`AbstractEpistasis`</span>
<span class="sd">        If `n_latent_phenotypes` &gt; 1, should be a fit model of the same</span>
<span class="sd">        type fit the same `binarymap` for one less latent phenotype. This</span>
<span class="sd">        is used to initialize the parameters. See :ref:`fitting_multi_latent`.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This is an abstract base class. It implements most of the epistasis model</span>
<span class="sd">    functionality, but requires subclasses to define the actual</span>
<span class="sd">    :ref:`global_epistasis_function` and :ref:`likelihood_calculation`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_NEARLY_ZERO</span> <span class="o">=</span> <span class="mf">1e-8</span>
    <span class="sd">&quot;&quot;&quot;float: lower bound for parameters that should be &gt; 0.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">binarymap</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">model_one_less_latent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class docstring.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binarymap</span> <span class="o">=</span> <span class="n">binarymap</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_latent_phenotypes</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`n_latent_phenotypes` must be integer &gt;= 1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_phenotypes</span> <span class="o">=</span> <span class="n">n_latent_phenotypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">binarylength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># cache computed values</span>

        <span class="c1"># initialize params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_likelihood_calc_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_lower_latent_phenotype_params</span><span class="p">(</span><span class="n">model_one_less_latent</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">model_one_less_latent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`n_latent_phenotypes` is 1, but &quot;</span>
                <span class="s2">&quot;`model_one_less_latent` is not `None`.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_lower_latent_phenotype_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_one_less_latent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set parameters for lower-order latent phenotypes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_one_less_latent : :class:`AbstractEpistasis`</span>
<span class="sd">            Model like `self` but fit with one less latent phenotype.</span>

<span class="sd">        Initializes all parameters relevant to the first :math:`K - 1`</span>
<span class="sd">        latent phenotypes as described in :ref:`fitting_multi_latent`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;calling with only 1 latent pheno&quot;</span>
        <span class="k">if</span> <span class="n">model_one_less_latent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`model_one_less_latent` cannot be `None` when &quot;</span>
                <span class="s2">&quot;fitting multiple latent phenotypes&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_one_less_latent</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`model_one_less_latent` not same type as current&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; object: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> versus &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">model_one_less_latent</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span> <span class="o">!=</span> <span class="n">model_one_less_latent</span><span class="o">.</span><span class="n">binarymap</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`model_one_less_latent` has different &quot;</span>
                <span class="s2">&quot;`binarymap` than current object.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">!=</span> <span class="p">(</span><span class="n">model_one_less_latent</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`model_one_less_latent` does not have 1 fewer &quot;</span>
                <span class="s2">&quot;latent phenotype than current object.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span> <span class="o">=</span> <span class="n">model_one_less_latent</span><span class="o">.</span><span class="n">_likelihood_calc_params</span>
        <span class="n">new_latenteffects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">new_latenteffects</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_epistasis_func_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">new_epistasis_func_params</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">):</span>
            <span class="n">ki</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">new_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_one_less_latent</span><span class="o">.</span><span class="n">_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>
            <span class="n">new_epistasis_func_params</span><span class="p">[</span>
                <span class="n">ki</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">model_one_less_latent</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">new_latenteffects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span> <span class="o">=</span> <span class="n">new_epistasis_func_params</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the internal `_cache` before pickling.</span>

<span class="sd">        See: https://docs.python.org/3/library/pickle.html#object.__getstate__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Methods / properties to set and get model parameters that are fit.</span>
    <span class="c1"># The setters must clear appropriate elements from the cache.</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_latenteffects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Latent effects of mutations and wildtype.</span>

<span class="sd">        The :math:`\beta_m` values followed by :math:`\beta_{\rm{wt}}` for</span>
<span class="sd">        the representation in Eq. :eq:`latent_phenotype_wt_vec`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects_val</span>

    <span class="nd">@_latenteffects</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_latenteffects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;invalid value for `_latenteffects`:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;shape should be: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="si">}</span><span class="s2"> by &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but trying to set to: </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_latenteffects_val&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">!=</span> <span class="n">val</span>
        <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects_val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects_val</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Parameters for likelihood calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params_val</span>

    <span class="nd">@_likelihood_calc_params</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_names</span><span class="p">),):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid length for `_likelihood_calc_params`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_likelihood_calc_params_val&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">val</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span>
        <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params_val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params_val</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: :meth:`AbstractEpistasis.epistasis_func` params.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params_val</span>

    <span class="nd">@_epistasis_func_params</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid value for `_epistasis_func_params`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_epistasis_func_params_val&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">val</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span>
        <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params_val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params_val</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Methods / properties to get model parameters in useful formats</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">binarymap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`BinaryMap &lt;https://github.com/jbloomlab/binarymap&gt;`_</span>

<span class="sd">        The binary map is set during initialization of the model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binarymap</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_latent_phenotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: number of latent phenotypes, see :ref:`multi_latent`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_phenotypes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_binary_variants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;scipy.sparse.csr.csr_matrix: Binary variants with 1 in last column.</span>

<span class="sd">        As in Eq. :eq:`latent_phenotype_wt_vec` with :math:`\beta_{M+1}`.</span>
<span class="sd">        So this is a :math:`V` by :math:`M + 1` matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_binary_variants_val&quot;</span><span class="p">):</span>
            <span class="c1"># add column as here: https://stackoverflow.com/a/41947378</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_binary_variants_val</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">binary_variants</span><span class="p">,</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int8&quot;</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">],</span>
                <span class="p">],</span>
                <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_variants_val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;float: Aikake Information Criterion given current log likelihood.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nparams</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglik</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: Total number of parameters in model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_allparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_latent_phenotype_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process latent phenotype number to 0-based index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`)</span>
<span class="sd">            or `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            If `k` is valid latent phenotype number, return `k - 1`. If `k`</span>
<span class="sd">            is `None` and there is just one latent phenotype, return</span>
<span class="sd">            0. If `k` is `None` and there are multiple latent phenotypes,</span>
<span class="sd">            raise an errror.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;must set numerical value for `k` when &quot;</span>
                    <span class="s2">&quot;there are multiple latent phenotypes&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`k` must be &gt;= 1 and &lt;= `n_latent_phenotypes`&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AbstractEpistasis.latent_phenotype_wt"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.latent_phenotype_wt">[docs]</a>    <span class="k">def</span> <span class="nf">latent_phenotype_wt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Latent phenotype of wildtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Which latent phenotype to get (1 &lt;= k &lt;=</span>
<span class="sd">            :attr:`AbstractEpistasis.n_latent_phenotypes`). If there</span>
<span class="sd">            is just one latent phenotype, can also be `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        float</span>
<span class="sd">            Wildtype latent phenotype, which is :math:`\beta_{\rm{wt}}` in</span>
<span class="sd">            Eq. :eq:`latent_phenotype` or :math:`\beta_{\rm{wt}}^k` in</span>
<span class="sd">            Eq. :eq:`latent_phenotype_multi`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span>
        <span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">epistasis_func_params_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;dict: Parameters for the :ref:`global_epistasis_function`.</span>

<span class="sd">        Maps names of parameters defining the global epistasis function to</span>
<span class="sd">        their current values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">suffixed_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">suffixed_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">:</span>
                    <span class="n">suffixed_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffixed_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">suffixed_names</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffixed_names</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">suffixed_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">likelihood_calc_params_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;dict: Parameters for the :ref:`likelihood_calculation`.</span>

<span class="sd">        Maps names of parameters defining the likelihood calculation to</span>
<span class="sd">        their current values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_names</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Methods to get phenotypes / mutational effects given current model state</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
<div class="viewcode-block" id="AbstractEpistasis.phenotypes_frombinary"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.phenotypes_frombinary">[docs]</a>    <span class="k">def</span> <span class="nf">phenotypes_frombinary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">binary_variants</span><span class="p">,</span>
        <span class="n">phenotype</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">wt_col</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Phenotypes from binary variant representations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binary_variants : scipy.sparse.csr.csr_matrix or numpy.ndarray</span>
<span class="sd">            Binary variants in form used by</span>
<span class="sd">            `BinaryMap &lt;https://github.com/jbloomlab/binarymap&gt;`_.</span>
<span class="sd">        phenotype : {&#39;latent&#39;, &#39;observed&#39;}</span>
<span class="sd">            Calculate the latent or observed phenotype.</span>
<span class="sd">        wt_col : bool</span>
<span class="sd">            Set to `True` if `binary_variants` contains a terminal</span>
<span class="sd">            column of ones to enable calculations in the form given</span>
<span class="sd">            by Eq. :eq:`latent_phenotype_wt_vec`.</span>
<span class="sd">        k : int or None</span>
<span class="sd">            If `phenotype` is &#39;latent&#39;, which latent phenotype to use (1 &lt;= k</span>
<span class="sd">            (&lt;= :attr:`AbstractEpistasis.n_latent_phenotypes`). If there</span>
<span class="sd">            is just one latent phenotype, can also be `None`. Has no meaning</span>
<span class="sd">            if `phenotype` is &#39;observed&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Latent phenotypes calculated using Eq. :eq:`latent_phenotype` or</span>
<span class="sd">            observed phenotypes calculated using Eq. :eq:`observed_phenotype`</span>
<span class="sd">            (or Eqs. :eq:`latent_phenotype_multi` or</span>
<span class="sd">            :eq:`observed_phenotype_multi`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">binary_variants</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`binary_variants` not 2D:</span><span class="se">\n</span><span class="si">{</span><span class="n">binary_variants</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binary_variants</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">wt_col</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;variants wrong length: </span><span class="si">{</span><span class="n">binary_variants</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">phenotype</span> <span class="o">==</span> <span class="s2">&quot;latent&quot;</span><span class="p">:</span>
            <span class="n">ki</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wt_col</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_variants</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_variants</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_phenotype_wt</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">phenotype</span> <span class="o">==</span> <span class="s2">&quot;observed&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wt_col</span><span class="p">:</span>
                <span class="n">latents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">latents</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">binary_variants</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">latent_phenos</span> <span class="o">=</span> <span class="n">binary_variants</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">latents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[</span>
                    <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="k">assert</span> <span class="n">latents</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">binary_variants</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">latent_phenos</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">binary_variants</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">latent_phenotype_wt</span><span class="p">(</span><span class="n">kj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">kj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">latent_phenos</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
                <span class="n">binary_variants</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">observed_phenos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">binary_variants</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">):</span>
                <span class="n">observed_phenos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func</span><span class="p">(</span><span class="n">latent_phenos</span><span class="p">[</span><span class="n">kj</span><span class="p">],</span> <span class="n">kj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">observed_phenos</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">latent_effects_df</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pandas.DataFrame: Latent effects of mutations.</span>

<span class="sd">        For each single mutation in :attr:`AbstractEpistasis.binarymap`, gives</span>
<span class="sd">        current predicted latent effect of that mutation. If there are multiple</span>
<span class="sd">        latent phenotypes (:attr:`AbstractEpistasis.n_latent_phenotypes` &gt; 1),</span>
<span class="sd">        also indicates the phenotype number of the latent effect.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">all_subs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;mutation&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">all_subs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="s2">&quot;latent_effect&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;latent_phenotype_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">all_subs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<div class="viewcode-block" id="AbstractEpistasis.add_phenotypes_to_df"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.add_phenotypes_to_df">[docs]</a>    <span class="k">def</span> <span class="nf">add_phenotypes_to_df</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">substitutions_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">latent_phenotype_col</span><span class="o">=</span><span class="s2">&quot;latent_phenotype&quot;</span><span class="p">,</span>
        <span class="n">observed_phenotype_col</span><span class="o">=</span><span class="s2">&quot;observed_phenotype&quot;</span><span class="p">,</span>
        <span class="n">phenotype_col_overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">unknown_as_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add predicted phenotypes to data frame of variants.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            Data frame containing variants.</span>
<span class="sd">        substitutions_col : str or None</span>
<span class="sd">            Column in `df` giving variants as substitution strings in format</span>
<span class="sd">            that can be processed by :attr:`AbstractEpistasis.binarymap`.</span>
<span class="sd">            If `None`, defaults to the `substitutions_col` attribute of</span>
<span class="sd">            that binary map.</span>
<span class="sd">        latent_phenotype_col : str</span>
<span class="sd">            Column(s) added to `df` containing predicted latent phenotypes.</span>
<span class="sd">            If there are multiple latent phenotypes, this string is suffixed</span>
<span class="sd">            with the latent phenotype number (i.e., &#39;latent_phenotype_1&#39;).</span>
<span class="sd">        observed_phenotype_col : str</span>
<span class="sd">            Column added to `df` containing predicted observed phenotypes.</span>
<span class="sd">        phenotype_col_overwrite : bool</span>
<span class="sd">            If the specified latent or observed phenotype column already</span>
<span class="sd">            exist in `df`, overwrite it? If `False`, raise an error.</span>
<span class="sd">        unknown_as_nan : bool</span>
<span class="sd">            If some of the substitutions in a variant are not present in</span>
<span class="sd">            the model (not in :attr:`AbstractEpistasis.binarymap`) set the</span>
<span class="sd">            phenotypes to `nan` (not a number)? If `False`, raise an error.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A copy of `df` with the phenotypes added. Phenotypes are predicted</span>
<span class="sd">            based on the current state of the model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">substitutions_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">substitutions_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">substitutions_col</span>
        <span class="k">if</span> <span class="n">substitutions_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`df` lacks `substitutions_col` &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">substitutions_col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">latent_phenotype_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">latent_phenotype_col</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">latent_phenotype_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">latent_phenotype_col</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="p">{</span><span class="n">substitutions_col</span><span class="p">,</span> <span class="n">observed_phenotype_col</span><span class="p">,</span> <span class="o">*</span><span class="n">latent_phenotype_cols</span><span class="p">}</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;repeated name among `latent_phenotype_col`, &quot;</span>
                <span class="s2">&quot;`observed_phenotype_col`, `substitutions_col`&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">latent_phenotype_cols</span> <span class="o">+</span> <span class="p">[</span><span class="n">observed_phenotype_col</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">phenotype_col_overwrite</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">phenotype_col_overwrite</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`df` already contains column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># build binary variants as csr matrix</span>
        <span class="n">row_ind</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># row indices of elements that are one</span>
        <span class="n">col_ind</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># column indices of elements that are one</span>
        <span class="n">nan_variant_indices</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># indices of variants that are nan</span>
        <span class="k">for</span> <span class="n">ivariant</span><span class="p">,</span> <span class="n">subs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">substitutions_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">sub_str_to_indices</span><span class="p">(</span><span class="n">subs</span><span class="p">):</span>
                    <span class="n">row_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ivariant</span><span class="p">)</span>
                    <span class="n">col_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isub</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unknown_as_nan</span><span class="p">:</span>
                    <span class="n">nan_variant_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ivariant</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Variant has substitutions not in model:&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">subs</span><span class="si">}</span><span class="se">\n</span><span class="s2">Maybe use `unknown_as_nan`?&quot;</span>
                    <span class="p">)</span>
        <span class="n">binary_variants</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row_ind</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int8&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">binarylength</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int8&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">phenotype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">latent_phenotype_cols</span> <span class="o">+</span> <span class="p">[</span><span class="n">observed_phenotype_col</span><span class="p">],</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;observed&quot;</span><span class="p">],</span>
        <span class="p">):</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes_frombinary</span><span class="p">(</span><span class="n">binary_variants</span><span class="p">,</span> <span class="n">phenotype</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># needed because vals not might be writable</span>
            <span class="n">vals</span><span class="p">[</span><span class="n">nan_variant_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="k">return</span> <span class="n">df</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phenotypes_df</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pandas.DataFrame: Phenotypes of variants used to fit model.</span>

<span class="sd">        For each variant in :attr:`AbstractEpistasis.binarymap`, gives</span>
<span class="sd">        the current predicted latent and observed phenotypes as well</span>
<span class="sd">        as the functional score and its variance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">substitutions_col</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">substitution_variants</span><span class="p">),</span>
            <span class="s2">&quot;func_score&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span><span class="p">,</span>
            <span class="s2">&quot;func_score_var&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;latent_phenotype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;latent_phenotype_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;observed_phenotype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<div class="viewcode-block" id="AbstractEpistasis.preferences"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.preferences">[docs]</a>    <span class="k">def</span> <span class="nf">preferences</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">phenotype</span><span class="p">,</span>
        <span class="n">base</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">missing</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span>
        <span class="n">exclude_chars</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,),</span>
        <span class="n">returnformat</span><span class="o">=</span><span class="s2">&quot;wide&quot;</span><span class="p">,</span>
        <span class="n">stringency_param</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get preference of each site for each character.</span>

<span class="sd">        Use the latent or observed phenotype to estimate the preference</span>
<span class="sd">        :math:`\pi_{r,a}` of each site :math:`r` for each character (e.g.,</span>
<span class="sd">        amino acid) :math:`a`. These preferences can be displayed in logo plots</span>
<span class="sd">        or used as input to `phydms &lt;https://jbloomlab.github.io/phydms/&gt;`_</span>
<span class="sd">        in experimentally informed substitution models.</span>

<span class="sd">        The preferences are calculated from the phenotypes as follows. Let</span>
<span class="sd">        :math:`p_{r,a}` be the phenotype of the variant with the single</span>
<span class="sd">        mutation of site :math:`r` to :math:`a` (when :math:`a` is the wildtype</span>
<span class="sd">        character, then :math:`p_{r,a}` is the phenotype of the wildtype</span>
<span class="sd">        sequence). Then the preference :math:`\pi_{r,a}` is defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">           \pi_{r,a} = \frac{b^{p_{r,a}}}{\sum_{a&#39;} b^{p_{r,a&#39;}}}</span>

<span class="sd">        where :math:`b` is the base for the exponent. This definition</span>
<span class="sd">        ensures that the preferences sum to one at each site.</span>

<span class="sd">        The alphabet from which the characters are drawn and the site</span>
<span class="sd">        numbers are extracted from :attr:`AbstractEpistasis.binarymap`.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The &quot;flatness&quot; of the preferences is determined by the exponent base.</span>
<span class="sd">        A smaller `base` yields flatter preferences. There is no obvious &quot;best&quot;</span>
<span class="sd">        `base` as different values correspond to different linear scalings of</span>
<span class="sd">        of the phenotype. A recommended approach is simply to choose a value of</span>
<span class="sd">        `base` and then re-scale the preferences by using</span>
<span class="sd">        `phydms &lt;https://jbloomlab.github.io/phydms/&gt;`_ to optimize a</span>
<span class="sd">        stringency parameter (`see here &lt;https://peerj.com/articles/3657&gt;`_).</span>
<span class="sd">        The stringency parameter and the `base` chosen here both apply the</span>
<span class="sd">        same transformation to the data: linear scaling of the phenotypes.</span>
<span class="sd">        But note that `phydms &lt;https://jbloomlab.github.io/phydms/&gt;`_</span>
<span class="sd">        has an upper bound on the largest stringency parameter it can fit,</span>
<span class="sd">        so if you are hitting this upper bound then pre-scale the preferences</span>
<span class="sd">        to be less flat by using a larger value of `base`. In particular,</span>
<span class="sd">        the latent phenotypes from many of the epistasis models are scaled</span>
<span class="sd">        during fitting to have a relatively tight range, so you may need a</span>
<span class="sd">        large value of `base` such as 50.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phenotype : {&#39;observed&#39;, &#39;latent&#39;}</span>
<span class="sd">            Calculate the preferences from observed or latent phenotypes?</span>
<span class="sd">            Note that if there are multiple latent phenotypes, you must</span>
<span class="sd">            also set `k`.</span>
<span class="sd">        base : float</span>
<span class="sd">            Base to which the exponent is taken in computing the preferences.</span>
<span class="sd">        missing : {&#39;average&#39;, &#39;site_average&#39;, &#39;error&#39;}</span>
<span class="sd">            What to do when there is no estimate of the phenotype for one of</span>
<span class="sd">            the single mutants? Estimate the phenotype as the average of</span>
<span class="sd">            all single mutants, as the average of all single mutants at that</span>
<span class="sd">            site, or raise an error.</span>
<span class="sd">        exclude_chars : tuple or list</span>
<span class="sd">            Characters to exclude when calculating preferences (and when</span>
<span class="sd">            averaging values for missing mutants). For instance, you might</span>
<span class="sd">            want to exclude stop codons.</span>
<span class="sd">        returnformat : {&#39;tidy&#39;, &#39;wide&#39;}</span>
<span class="sd">            Return preferences in tidy or wide format data frame.</span>
<span class="sd">        stringency_param : float</span>
<span class="sd">            Re-scale preferences by this stringency parameter. This</span>
<span class="sd">            involves raising each preference to the power of</span>
<span class="sd">            `stringency_param`, and then re-normalizes. A similar</span>
<span class="sd">            effect can be achieved by changing `base`.</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Which latent phenotype to use (1 &lt;= k &lt;=</span>
<span class="sd">            :attr:`AbstractEpistasis.n_latent_phenotypes`). If there</span>
<span class="sd">            is just one latent phenotype, can also be `None`. Has no</span>
<span class="sd">            meaning if `phenotype` is &#39;observed&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            Data frame where first column is named &#39;site&#39;, other columns are</span>
<span class="sd">            named for each character, and rows give preferences for each site.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">effects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_mut_effects</span><span class="p">(</span>
            <span class="n">phenotype</span><span class="p">,</span>
            <span class="n">include_wildtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">standardize_range</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># get alphabet of non-excluded characters</span>
        <span class="n">alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">alphabet</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_chars</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dms_variants</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">scores_to_prefs</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">effects</span><span class="p">[[</span><span class="s2">&quot;mutation&quot;</span><span class="p">,</span> <span class="s2">&quot;effect&quot;</span><span class="p">]],</span>
            <span class="n">mutation_col</span><span class="o">=</span><span class="s2">&quot;mutation&quot;</span><span class="p">,</span>
            <span class="n">score_col</span><span class="o">=</span><span class="s2">&quot;effect&quot;</span><span class="p">,</span>
            <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span>
            <span class="n">wt_score</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
            <span class="n">alphabet</span><span class="o">=</span><span class="n">alphabet</span><span class="p">,</span>
            <span class="n">exclude_chars</span><span class="o">=</span><span class="n">exclude_chars</span><span class="p">,</span>
            <span class="n">returnformat</span><span class="o">=</span><span class="n">returnformat</span><span class="p">,</span>
            <span class="n">stringency_param</span><span class="o">=</span><span class="n">stringency_param</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AbstractEpistasis.single_mut_effects"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.single_mut_effects">[docs]</a>    <span class="k">def</span> <span class="nf">single_mut_effects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">phenotype</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">include_wildtype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">standardize_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Effects of single mutations on latent or observed phenotype.</span>

<span class="sd">        For the effects on observed phenotype, this is how much the mutation</span>
<span class="sd">        changes the observed phenotype relative to wildtype. Effects are</span>
<span class="sd">        reported only for mutations present in `AbstractEpistasis.binarymap`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        phenotype : {&#39;latent&#39;, &#39;observed&#39;}</span>
<span class="sd">            Get effect on this phenotype. If there are multiple latent</span>
<span class="sd">            phenotypes, you must also set `k`.</span>
<span class="sd">        include_wildtype : bool</span>
<span class="sd">            Include the effect of &quot;mutating&quot; to wildtype identity at a site</span>
<span class="sd">            (always zero).</span>
<span class="sd">        standardize_range : bool</span>
<span class="sd">            Scale effects so that the mean absolute value effect is one</span>
<span class="sd">            (scaling is done before including wildtype).</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Which latent phenotype to use (1 &lt;= k &lt;=</span>
<span class="sd">            :attr:`AbstractEpistasis.n_latent_phenotypes`). If there</span>
<span class="sd">            is just one latent phenotype, can also be `None`. Has no</span>
<span class="sd">            meaning if `phenotype` is &#39;observed&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The effects of all single mutations. Columns are:</span>

<span class="sd">              - &#39;mutation&#39;: mutation as str</span>
<span class="sd">              - &#39;wildtype&#39;: wildtype identity at site</span>
<span class="sd">              - &#39;site&#39;: site number</span>
<span class="sd">              - &#39;mutant&#39;: mutant identity at site</span>
<span class="sd">              - &#39;effect&#39;: effect of mutation on latent or observed phenotype</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">phenotype</span> <span class="o">==</span> <span class="s2">&quot;observed&quot;</span><span class="p">:</span>
            <span class="n">phenotypecol</span> <span class="o">=</span> <span class="s2">&quot;observed_phenotype&quot;</span>
        <span class="k">elif</span> <span class="n">phenotype</span> <span class="o">==</span> <span class="s2">&quot;latent&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">phenotypecol</span> <span class="o">=</span> <span class="s2">&quot;latent_phenotype&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">phenotypecol</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;latent_phenotype_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `phenotype` </span><span class="si">{</span><span class="n">phenotype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># data frame with all observed single mutations and phenotypes</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_phenotypes_to_df</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;mutation&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">all_subs</span><span class="p">}),</span>
            <span class="n">substitutions_col</span><span class="o">=</span><span class="s2">&quot;mutation&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># get wildtype phenotype</span>
        <span class="n">wt_phenotype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_phenotypes_to_df</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;mutation&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]}),</span> <span class="n">substitutions_col</span><span class="o">=</span><span class="s2">&quot;mutation&quot;</span>
        <span class="p">)[</span><span class="n">phenotypecol</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># subtract wildtype phenotype to get effects</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;effect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">phenotypecol</span><span class="p">]</span> <span class="o">-</span> <span class="n">wt_phenotype</span>

        <span class="k">if</span> <span class="n">standardize_range</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;effect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;effect&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;effect&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="c1"># extract wildtype, site, mutant from mutation</span>
        <span class="n">chars_regex</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">alphabet</span><span class="p">))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mutation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span>
                <span class="sa">rf</span><span class="s2">&quot;^(?P&lt;wildtype&gt;[</span><span class="si">{</span><span class="n">chars_regex</span><span class="si">}</span><span class="s2">])&quot;</span>
                <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;(?P&lt;site&gt;\-?\d+)&quot;</span>
                <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;(?P&lt;mutant&gt;[</span><span class="si">{</span><span class="n">chars_regex</span><span class="si">}</span><span class="s2">])$&quot;</span>
            <span class="p">)</span>
        <span class="p">)[[</span><span class="s2">&quot;mutation&quot;</span><span class="p">,</span> <span class="s2">&quot;wildtype&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;mutant&quot;</span><span class="p">,</span> <span class="s2">&quot;effect&quot;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">include_wildtype</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">df</span><span class="p">,</span>
                    <span class="p">(</span>
                        <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;wildtype&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">]]</span>
                        <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">assign</span><span class="p">(</span>
                            <span class="n">mutant</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;wildtype&quot;</span><span class="p">],</span>
                            <span class="n">mutation</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span>
                                <span class="n">x</span><span class="p">[</span><span class="s2">&quot;wildtype&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;mutant&quot;</span><span class="p">]</span>
                            <span class="p">),</span>
                            <span class="n">effect</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">],</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">site</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;effect&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;mutant&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AbstractEpistasis.enrichments"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.enrichments">[docs]</a>    <span class="k">def</span> <span class="nf">enrichments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">observed_phenotypes</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculated enrichment ratios from observed phenotypes.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        In many cases, the functional scores used to fit the model are the</span>
<span class="sd">        logarithm (most commonly base 2) of experimentally observed enrichments</span>
<span class="sd">        For example, this is how functional scores are calculated by</span>
<span class="sd">        :meth:`dms_variants.codonvarianttable.CodonVariantTable.func_scores`.</span>
<span class="sd">        In that case, the predicted enrichment value :math:`E\left(v\right)`</span>
<span class="sd">        for each variant :math:`v` can be computed from the observed phenotype</span>
<span class="sd">        :math:`p\left(v\right)` as:</span>

<span class="sd">        .. math::</span>

<span class="sd">           E\left(v\right) = B^{p\left(v\right) - p\left(\rm{wt}\right)}</span>

<span class="sd">        where :math:`p\left(\rm{wt}\right)` is the observed phenotype</span>
<span class="sd">        of wildtype, and :math:`B` is the base for the exponent (by default</span>
<span class="sd">        :math:`B = 2`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        observed_phenotypes : float or numpy.ndarray</span>
<span class="sd">            The observed phenotypes.</span>
<span class="sd">        base : float</span>
<span class="sd">            The base for the exponent used to convert observed phenotypes</span>
<span class="sd">            to enrichments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            The enrichments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">observed_phenotype_wt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes_frombinary</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span><span class="p">)),</span> <span class="s2">&quot;observed&quot;</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">observed_phenotypes</span> <span class="o">-</span> <span class="n">observed_phenotype_wt</span><span class="p">)</span></div>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Methods / properties used for model fitting. Many of these are properties</span>
    <span class="c1"># that store the current state for the variants we are fitting, using the</span>
    <span class="c1"># cache so that they don&#39;t have to be re-computed needlessly.</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
<div class="viewcode-block" id="AbstractEpistasis.fit"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">use_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize_method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">clearcache</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit all model params to maximum likelihood values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_grad : bool</span>
<span class="sd">            Use analytical gradients to help with fitting.</span>
<span class="sd">        optimize_method : {&#39;L-BFGS-B&#39;, &#39;TNC&#39;}</span>
<span class="sd">            Optimization method used by `scipy.optimize.minimize`.</span>
<span class="sd">        ftol : float</span>
<span class="sd">            Function convergence tolerance for optimization, used by</span>
<span class="sd">            `scipy.optimize.minimize`.</span>
<span class="sd">        clearcache : bool</span>
<span class="sd">            Clear the cache after model fitting? This slightly increases</span>
<span class="sd">            the time needed to compute properties after fitting, but</span>
<span class="sd">            greatly saves memory usage.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scipy.optimize.OptimizeResult</span>
<span class="sd">            The results of optimizing the full model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Least squares fit of latent effects for reasonable initial values</span>
        <span class="c1"># for the first latent phenotype:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_latent_leastsquares</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prescale_params</span><span class="p">(</span>
                <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">g_k_range</span><span class="o">=</span><span class="p">(</span>
                    <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span><span class="p">),</span>
                    <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span><span class="p">),</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">phenos_Kminus1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">))</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">(</span>
                <span class="n">phenos_Kminus1</span>
            <span class="p">)</span>
            <span class="n">max_abs_residual</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prescale_params</span><span class="p">(</span>
                <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
                <span class="n">g_k_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">max_abs_residual</span><span class="p">,</span> <span class="n">max_abs_residual</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># optimize full model by maximum likelihood</span>
        <span class="n">optres</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
            <span class="n">fun</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loglik_by_allparams</span><span class="p">,</span>
            <span class="n">jac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_by_allparams</span> <span class="k">if</span> <span class="n">use_grad</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_allparams</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">optimize_method</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_allparams_bounds</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ftol&quot;</span><span class="p">:</span> <span class="n">ftol</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optres</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EpistasisFittingError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Fitting of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> failed after &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">optres</span><span class="o">.</span><span class="n">nit</span><span class="si">}</span><span class="s2"> iterations. Message:</span><span class="se">\n</span><span class="si">{</span><span class="n">optres</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">optres</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allparams</span> <span class="o">=</span> <span class="n">optres</span><span class="o">.</span><span class="n">x</span>

        <span class="c1"># postscale parameters to desired range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postscale_params</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">clearcache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="n">optres</span></div>

    <span class="k">def</span> <span class="nf">_loglik_by_allparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allparams</span><span class="p">,</span> <span class="n">negative</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(Negative) log likelihood after setting all parameters.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Calling this method alters the internal model parameters, so only</span>
<span class="sd">        use if you understand what you are doing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        allparams : numpy.ndarray</span>
<span class="sd">            Parameters used to set :meth:`AbstractEpistasis._allparams`.</span>
<span class="sd">        negative : bool</span>
<span class="sd">            Return negative log likelihood. Useful if using a minimizer to</span>
<span class="sd">            optimize.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            (Negative) log likelihood after setting parameters to `allparams`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allparams</span> <span class="o">=</span> <span class="n">allparams</span>
        <span class="k">if</span> <span class="n">negative</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">loglik</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglik</span>

    <span class="k">def</span> <span class="nf">_dloglik_by_allparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allparams</span><span class="p">,</span> <span class="n">negative</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(Negative) derivative of log likelihood with respect to all params.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Calling this method alters the internal model parameters, so only</span>
<span class="sd">        use if you understand what you are doing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        allparams: numpy.ndarray</span>
<span class="sd">            Parameters used to set :meth:`AbstractEpistasis._allparams`.</span>
<span class="sd">        negative : bool</span>
<span class="sd">            Return negative log likelihood. Useful if using a minimizer to</span>
<span class="sd">            optimize.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            (Negative) derivative of log likelihood with respect to</span>
<span class="sd">            :meth:`AbstractEpistasis._allparams`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allparams</span> <span class="o">=</span> <span class="n">allparams</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_dlatent</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_dlikelihood_calc_params</span><span class="p">,</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_depistasis_func_params</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nparams</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">negative</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_allparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: All model parameters in a single array.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This property should only be used for purposes in which it is</span>
<span class="sd">        necessary to get or set all params in a single vector (typically</span>
<span class="sd">        for model optimiziation), **not** to access the values of specific</span>
<span class="sd">        parameters, since the order of parameters in the array may change</span>
<span class="sd">        in future implementations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@_allparams</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_allparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nparams</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `_allparams`: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">istart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># add 1 for wt latent phenotype</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ncol</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">istart</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
        <span class="n">istart</span> <span class="o">+=</span> <span class="n">n</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">istart</span> <span class="p">:</span> <span class="n">istart</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="n">istart</span> <span class="o">+=</span> <span class="n">n</span>

        <span class="n">ncol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ncol</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">istart</span> <span class="p">:</span> <span class="n">istart</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="n">ncol</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_allparams_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Bounds for :meth:`AbstractEpistasis._allparams`.</span>

<span class="sd">        Can be passed to `scipy.optimize.minimize`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">size</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_bounds</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_bounds</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_allparams</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;len(bounds) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;_allparams.shape = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_allparams</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bounds</span>

    <span class="k">def</span> <span class="nf">_latent_phenotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Latent phenotypes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`),</span>
<span class="sd">            or can be `None` if just one latent phenotype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Latent phenotypes of all variants being used to fit model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_latent_phenotypes_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes_frombinary</span><span class="p">(</span>
                <span class="n">binary_variants</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_binary_variants</span><span class="p">,</span>
                <span class="n">phenotype</span><span class="o">=</span><span class="s2">&quot;latent&quot;</span><span class="p">,</span>
                <span class="n">wt_col</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_observed_phenotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_phenos</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Observed phenotypes of variants being fit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latent_phenos : &#39;all&#39; or list</span>
<span class="sd">            The numbers (:math:`k = 1, 2, \ldots...) of the latent phenotypes</span>
<span class="sd">            used to calculate the observed phenotype. If &#39;all&#39; use all</span>
<span class="sd">            latent phenotypes. Otherwise only include the terms in</span>
<span class="sd">            Eq. :eq:`observed_phenotype_multi` corresponding to the</span>
<span class="sd">            :math:`k` values listed here.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Observed phenotypes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">latent_phenos</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">latent_phenos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">latent_phenos</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">latent_phenos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">latent_phenos</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;duplicate entries in `latent_phenos`&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">latent_phenos</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entries in `latent_phenos`&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">latent_phenos</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;empty `latent_phenos`&quot;</span><span class="p">)</span>
            <span class="n">latent_phenos</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">latent_phenos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`latent_phenos` not a list&quot;</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_observed_phenotypes_</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">latent_phenos</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">observed_phenos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">latent_phenos</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">k</span><span class="o">=</span><span class="n">latent_phenos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">latent_phenos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">observed_phenos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">observed_phenos</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_dobserved_phenotypes_dlatent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative observed phenotype by latent effects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`),</span>
<span class="sd">            or can be `None` if just one latent phenotype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scipy.parse.csr_matrix</span>
<span class="sd">            Derivative observed pheno by latent effects for phenotype</span>
<span class="sd">            :math:`k`. See Eq. :eq:`dobserved_phenotype_dlatent_effect`.</span>
<span class="sd">            This is a :math:`M + 1` by :math:`V` matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_dobserved_phenotypes_dlatent_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span>
                <span class="n">key</span>
            <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_variants</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>  <span class="c1"># from V by M to M by V</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_depistasis_func_dlatent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_dloglik_dlatent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative log likelihood by latent effects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`),</span>
<span class="sd">            or can be `None` if just one latent phenotype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray:</span>
<span class="sd">            Derivative log likelihood by latent effects for phenotype</span>
<span class="sd">            :math:`k`. See Eq. :eq:`dloglik_dlatent_effect`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_dloglik_dlatent_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dobserved_phenotypes_dlatent</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_dobserved_phenotype</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_fit_latent_leastsquares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_to</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Least-squares fit latent effects for quick &quot;reasonable&quot; values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Fit effects for this latent phenotype (1 &lt;= `k` &lt;=</span>
<span class="sd">            `n_latent_phenotypes`); can be `None` if just one latent phenotype.</span>
<span class="sd">        fit_to : numpy.ndarray or None</span>
<span class="sd">            Fit latent effects to these values. If `None`, fits to</span>
<span class="sd">            :attr:`AbstractEpistasis.binarymap.func_scores`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Results of fitting described here:</span>
<span class="sd">            https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lsqr.html</span>

<span class="sd">        In addition to returning the fitting results, sets the latent</span>
<span class="sd">        effects to the new fit value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ki</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fit_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fit_to</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`invalid shape for `fit_to`&quot;</span><span class="p">)</span>

        <span class="c1"># fit by least squares</span>
        <span class="n">fitres</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lsqr</span><span class="p">(</span>
            <span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_binary_variants</span><span class="p">,</span>
            <span class="n">b</span><span class="o">=</span><span class="n">fit_to</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># use fit result to update latenteffects</span>
        <span class="n">new_latenteffects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">new_latenteffects</span>

        <span class="k">return</span> <span class="n">fitres</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Abstract methods for global epistasis func, must implement in subclasses</span>
    <span class="c1"># specific for that epistasis model.</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
<div class="viewcode-block" id="AbstractEpistasis.epistasis_func"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.AbstractEpistasis.epistasis_func">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">epistasis_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_phenotype</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :ref:`global_epistasis_function` :math:`g`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        latent_phenotype : numpy.ndarray</span>
<span class="sd">            Latent phenotype(s) of one or more variants.</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`),</span>
<span class="sd">            or can be `None` if just one latent phenotype. See</span>
<span class="sd">            Eq. :ref:`multi_latent`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Result of applying global epistasis function :math:`g_k` to latent</span>
<span class="sd">            phenotypes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_depistasis_func_dlatent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_phenotype</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative of epistasis function by latent phenotype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        latent_phenotype : numpy.ndarray</span>
<span class="sd">            Latent phenotype(s) of one or more variants.</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`),</span>
<span class="sd">            or can be `None` if just one latent phenotype. See</span>
<span class="sd">            Eq. :ref:`multi_latent`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Derivative of :meth:`NoEpistasis.epistasis_func` for</span>
<span class="sd">            latent phenotype `k` evaluated at `latent_phenotype`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_dloglik_depistasis_func_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deriv log likelihood by `_epistasis_func_params` for :math:`g_k`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`),</span>
<span class="sd">            or can be `None` if just one latent phenotype. See</span>
<span class="sd">            Eq. :ref:`multi_latent`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The derivative with respect to the parameters for epistasis</span>
<span class="sd">            function :math:`g_k`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Names of :meth:`AbstractEpistasis._epistasis_func_params`.</span>

<span class="sd">        When there are multiple latent phenotypes and global epistasis</span>
<span class="sd">        functions (:ref:`multi_latent`) still just provide a list with</span>
<span class="sd">        one copy of each parameter name and they will be suffixed with</span>
<span class="sd">        :math:`k` by :meth:`AbstractEpistasis.epistasis_func_params_dict`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Bounds for the epistasis function parameters.</span>

<span class="sd">        For each entry in :meth:`AbstractEpistasis._epistasis_func_param_names`</span>
<span class="sd">        a 2-tuple gives the lower and upper bound for optimization by</span>
<span class="sd">        `scipy.optimize.minimize`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_prescale_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">g_k_range</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set / scale parameters prior to the global fitting.</span>

<span class="sd">        This method is designed to set / re-scale parameters relevant</span>
<span class="sd">        to the latent phenotype :math:`k` and its associated global</span>
<span class="sd">        epistasis function prior to fitting. The re-scaling differs</span>
<span class="sd">        for different model classes, and is implemented in concrete</span>
<span class="sd">        subclasses. See :ref:`fitting_workflow`.</span>

<span class="sd">        Importantly, this is the method that sets initial values</span>
<span class="sd">        for `_epistasis_func_params`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        k : int</span>
<span class="sd">            Latent phenotype number (1 &lt;= `k` &lt;= `n_latent_phenotypes`).</span>
<span class="sd">        g_k_range : tuple</span>
<span class="sd">            Gives desired min and max of :math:`g_k`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_postscale_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rescale parameters after the global fitting.</span>

<span class="sd">        This is an abstract method, any actual post-scaling is done in concrete</span>
<span class="sd">        subclasses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Abstract methods for likelihood calculations, implement in subclasses</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">loglik</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;float: Current log likelihood of model.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Names of :meth:`AbstractEpistasis._likelihood_calc_params`.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_init_likelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Initial `_likelihood_calc_params` values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Bounds for the likelihood calculation parameters.</span>

<span class="sd">        For entries in :meth:`AbstractEpistasis._likelihood_calc_param_names`,</span>
<span class="sd">        a 2-tuple gives the lower and upper bound for optimization by</span>
<span class="sd">        `scipy.optimize.minimize`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_dloglik_dobserved_phenotype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative log likelihood by observed phenotype.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_dloglik_dlikelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative log lik by `_likelihood_calc_params`.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_zero_wt_observed_pheno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;bool: Re-scale wildtype observed phenotype to 0 after fitting?</span>

<span class="sd">        Should be set to `False` for likelihood calculation methods that</span>
<span class="sd">        fit observed phenotypes directly to functional scores directly,</span>
<span class="sd">        and `True` for those that only fit observed phenotypes up to an</span>
<span class="sd">        arbitrary additive constant.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="CauchyLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.CauchyLikelihood">[docs]</a><span class="k">class</span> <span class="nc">CauchyLikelihood</span><span class="p">(</span><span class="n">AbstractEpistasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cauchy likelihood calculation.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Subclass of :class:`AbstractEpistasis` that implements the</span>
<span class="sd">    :ref:`cauchy_likelihood`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglik</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;float: Current log likelihood from Eq. :eq:`loglik_cauchy`.&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;loglik&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">scales</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_variances</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">scales</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;scales not all &gt; 0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">cauchy</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span><span class="p">,</span>
                    <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">(),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="n">scales</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_fit_latent_leastsquares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_to</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Also get initial value for scale parameter.</span>

<span class="sd">        Overrides :meth:`AbstractEpistasis._fit_latent_leastsquares`</span>
<span class="sd">        to make initial estimate of :math:`\gamma^2` as residual not</span>
<span class="sd">        from functional score variance. This is based on the supposition</span>
<span class="sd">        that the scale parameter can be treated like the variance for</span>
<span class="sd">        a Gaussian distribution (not sure how good this supposition is...).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fitres</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_fit_latent_leastsquares</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">fit_to</span><span class="o">=</span><span class="n">fit_to</span><span class="p">)</span>
        <span class="n">residuals2</span> <span class="o">=</span> <span class="n">fitres</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_param2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">residuals2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_param2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="p">(</span><span class="n">residuals2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="n">scale_param2</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;list: Likelihood calculation parameter names.</span>

<span class="sd">        For :class:`CauchyLikelihood`, this is the scale parameter</span>
<span class="sd">        :math:`\gamma`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;scale_parameter&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_init_likelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Initial `_likelihood_calc_params`.</span>

<span class="sd">        The initial scale parameter :math:`\gamma` is 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;scale_parameter&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">init_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;list: Bounds for likelihood calculation parameters.</span>

<span class="sd">        For :class:`CauchyLikelihood`, :math:`\gamma` must be &gt; 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds_d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;scale_parameter&quot;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">bounds_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_names</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dloglik_dobserved_phenotype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative of log likelihood by observed phenotype.</span>

<span class="sd">        Calculated using Eq. :eq:`dloglik_cauchy_dobserved_phenotype`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_dloglik_dobserved_phenotype&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_variances</span> <span class="o">+</span> <span class="n">diff</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dloglik_dlikelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative log lik by `_likelihood_calc_params`.</span>

<span class="sd">        See Eq. :eq:`dloglik_cauchy_dscale_parameter`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_dloglik_dlikelihood_calc_params&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">scale_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_calc_params_dict</span><span class="p">[</span><span class="s2">&quot;scale_parameter&quot;</span><span class="p">]</span>
            <span class="n">diff2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">scale_param</span>
                        <span class="o">*</span> <span class="p">(</span><span class="n">diff2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_variances</span><span class="p">)</span>
                        <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_variances</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_variances</span> <span class="o">+</span> <span class="n">diff2</span><span class="p">))</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pseudo_variances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Functional score variance plus scale param squared.</span>

<span class="sd">        :math:`\sigma_{y_v}^2 + \gamma^2` in Eq. :eq:`loglik_cauchy`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_pseudo_variances&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">scale_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_calc_params_dict</span><span class="p">[</span><span class="s2">&quot;scale_parameter&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span> <span class="o">+</span> <span class="n">scale_param</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span> <span class="n">scale_param</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">var</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variance &lt;= 0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_zero_wt_observed_pheno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;False: Do not re-scale wildtype observed phenotype to 0.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BottleneckLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.BottleneckLikelihood">[docs]</a><span class="k">class</span> <span class="nc">BottleneckLikelihood</span><span class="p">(</span><span class="n">AbstractEpistasis</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Bottleneck likelihood calculation.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Subclass of :class:`AbstractEpistasis` that implements the</span>
<span class="sd">    :ref:`bottleneck_likelihood`.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The :attr:`AbstractEpistasis.binarymap` must have non-`None`</span>
<span class="sd">    counts in its `n_pre` and `n_post` attributes, since</span>
<span class="sd">    as described in :ref:`bottleneck_likelihood`, the model is</span>
<span class="sd">    actually fit to the :attr:`BottleneckLikelihood.f_pre` and</span>
<span class="sd">    :attr:`BottleneckLikelihood.f_post` values calculated from</span>
<span class="sd">    these counts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bottleneck : float</span>
<span class="sd">        The estimated size of the experimental bottleneck between the</span>
<span class="sd">        pre- and post-selection conditions. This is the :math:`N_{\rm{bottle}}`</span>
<span class="sd">        parameter described in :ref:`bottleneck_likelihood`.</span>
<span class="sd">    pseudocount : float</span>
<span class="sd">        The pseudocount used when converting the counts to frequencies</span>
<span class="sd">        vi Eq. :eq:`f_v_pre_post`.</span>
<span class="sd">    base : float</span>
<span class="sd">        The exponent base in Eq. :eq:`n_v_bottle` used when exponentiating</span>
<span class="sd">        the observed phenotypes :math:`p\left(v\right)`. It is written</span>
<span class="sd">        as 2 in Eq. :eq:`n_v_bottle`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">binarymap</span><span class="p">,</span>
        <span class="n">bottleneck</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">model_one_less_latent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pseudocount</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">base</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class docstring.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pseudocount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`pseudocount` must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">]:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">binarymap</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`binarymap.n_</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">` is `None`&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `binarymap.n_</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">` shape&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;negative values in `binarymap.n_</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">pseudocount</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">/</span> <span class="n">f</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;non-positive values in `f_</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`f_</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">` has values that are nearly zero &quot;</span>
                    <span class="s2">&quot;which *might* cause numerical issues. Consider &quot;</span>
                    <span class="s2">&quot;increasing `pseudocount` if you have fitting &quot;</span>
                    <span class="s2">&quot;problems&quot;</span><span class="p">,</span>
                    <span class="n">EpistasisFittingWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_f_</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">base</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `base` of </span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">base</span>

        <span class="k">if</span> <span class="n">bottleneck</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`bottleneck` must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bottleneck</span> <span class="o">=</span> <span class="n">bottleneck</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">binarymap</span><span class="p">,</span>
            <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="n">model_one_less_latent</span><span class="o">=</span><span class="n">model_one_less_latent</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bottleneck</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;int: Bottleneck pre- to post-selection, :math:`N_{\rm{bottle}]`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bottleneck</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Pre-selection frequency of each variant.</span>

<span class="sd">        The :math:`f_v^{\rm{pre}}` values in Eq. :eq:`f_v_pre_post`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_pre</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Post-selection frequency of each variant.</span>

<span class="sd">        The :math:`f_v^{\rm{post}}` values in Eq. :eq:`f_v_pre_post`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_post</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglik</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;float: Current log likelihood from Eq. :eq:`loglik_bottleneck`.&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;loglik&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_v_bottle</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_N_bottle_f_pre</span>
                <span class="o">-</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">loggamma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_v_bottle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottleneck</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;list: Likelihood calculation parameter names.</span>

<span class="sd">        For :class:`BottleneckLikelihood`, there are no such parameters as</span>
<span class="sd">        :math:`N_{\rm{bottle}}` must be determined experimentally.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_init_likelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Initial `_likelihood_calc_params`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Bounds for likelihood calculation parameters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dloglik_dobserved_phenotype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative of log likelihood by observed phenotype.</span>

<span class="sd">        Calculating using Eq. :eq:`dloglik_bottleneck_dobserved_phenotype`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_dloglik_dobserved_phenotype&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="mi">2</span>
            <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_pre</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_to_observed_pheno</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottleneck</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_post</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_to_observed_pheno</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_N_bottle_f_pre</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digamma_n_v_bottle_1</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="mi">2</span>
            <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_v_bottle</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log_N_bottle_f_pre</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digamma_n_v_bottle_1</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,)</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dloglik_dlikelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative of log lik by `_likelihood_calc_params`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_base_to_observed_pheno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: `base` raised to observed phenotype.</span>

<span class="sd">        This is :math:`2^{p\left(v\right)` in Eq. :eq:`n_v_bottle`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_base_to_observed_pheno&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,)</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_log_N_bottle_f_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Log of N_bottle * f_v_pre.</span>

<span class="sd">        :math:`\ln\left(N_{\rm{bottle}} f_v^{\rm{pre}}\right)` in</span>
<span class="sd">        Eq. :eq:`loglik_bottleneck`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_log_N_bottle_f_pre&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bottleneck</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_pre</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,)</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_n_v_bottle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: :math:`n_v^{\rm{bottle}}` (Eq. :eq:`n_v_bottle`).&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_n_v_bottle&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">sumterm</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_pre</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_to_observed_pheno</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_post</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottleneck</span> <span class="o">*</span> <span class="n">sumterm</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_to_observed_pheno</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,)</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_digamma_n_v_bottle_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: :math:`\psi_0\left(n_v^{\rm{bottle}} + 1\right)`.&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_digamma_n_v_bottle_1&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_v_bottle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,)</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_zero_wt_observed_pheno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True: Re-scale wildtype observed phenotype to 0 after fitting.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="GaussianLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.GaussianLikelihood">[docs]</a><span class="k">class</span> <span class="nc">GaussianLikelihood</span><span class="p">(</span><span class="n">AbstractEpistasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gaussian likelihood calculation.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Subclass of :class:`AbstractEpistasis` that implements the</span>
<span class="sd">    :ref:`gaussian_likelihood`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglik</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;float: Current log likelihood from Eq. :eq:`loglik_gaussian`.&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;loglik&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">standard_devs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variances</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">standard_devs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;standard deviations not all &gt; 0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span><span class="p">,</span>
                    <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">(),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="n">standard_devs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_fit_latent_leastsquares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_to</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Also get initial value for HOC epistasis.</span>

<span class="sd">        Overrides :meth:`AbstractEpistasis._fit_latent_leastsquares`</span>
<span class="sd">        to make initial estimate of :math:`\sigma^2_{\rm{HOC}}` as</span>
<span class="sd">        residual not from functional score variance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fitres</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_fit_latent_leastsquares</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">fit_to</span><span class="o">=</span><span class="n">fit_to</span><span class="p">)</span>
        <span class="n">residuals2</span> <span class="o">=</span> <span class="n">fitres</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epistasis_HOC</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">residuals2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epistasis_HOC</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="p">(</span><span class="n">residuals2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">epistasis_HOC</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;list: Likelihood calculation parameter names.</span>

<span class="sd">        For :class:`GaussianLikelihood`, this :math:`\sigma^2_{\rm{HOC}}`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;epistasis_HOC&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_init_likelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Initial `_likelihood_calc_params`.</span>

<span class="sd">        The initial HOC epistasis :math:`\sigma^2_{\rm{HOC}}` is 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;epistasis_HOC&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">init_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_likelihood_calc_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;list: Bounds for likelihood calculation parameters.</span>

<span class="sd">        For :class:`GaussianLikelihood`, :math:`\sigma^2_{\rm{HOC}}` must</span>
<span class="sd">        be &gt; 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds_d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;epistasis_HOC&quot;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">bounds_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_param_names</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dloglik_dobserved_phenotype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative of log likelihood by observed phenotype.</span>

<span class="sd">        Calculated using Eq. :eq:`dloglik_gaussian_dobserved_phenotype`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_dloglik_dobserved_phenotype&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">()</span>
            <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variances</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dloglik_dlikelihood_calc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: Derivative log lik by `_likelihood_calc_params`.</span>

<span class="sd">        See Eq. :eq:`dloglik_gaussian_depistasis_HOC`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_dloglik_dlikelihood_calc_params&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="mf">0.5</span>
                    <span class="o">*</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_dobserved_phenotype</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variances</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_calc_params</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_variances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Functional score variance plus HOC epistasis.</span>

<span class="sd">        :math:`\sigma_{y_v}^2 + \sigma_{\rm{HOC}}^2` in</span>
<span class="sd">        Eq. :eq:`loglik_gaussian`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;_variances&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">epistasis_HOC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_calc_params_dict</span><span class="p">[</span><span class="s2">&quot;epistasis_HOC&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">func_scores_var</span> <span class="o">+</span> <span class="n">epistasis_HOC</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binarymap</span><span class="o">.</span><span class="n">nvariants</span><span class="p">,</span> <span class="n">epistasis_HOC</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">var</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variance &lt;= 0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_zero_wt_observed_pheno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;False: Do not re-scale wildtype observed phenotype to 0.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="NoEpistasis"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.NoEpistasis">[docs]</a><span class="k">class</span> <span class="nc">NoEpistasis</span><span class="p">(</span><span class="n">AbstractEpistasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Non-epistatic model.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Subclass of :class:`AbstractEpistasis` that implements the</span>
<span class="sd">    :ref:`no_epistasis_function`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NoEpistasis.epistasis_func"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.NoEpistasis.epistasis_func">[docs]</a>    <span class="k">def</span> <span class="nf">epistasis_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_phenotype</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Global epistasis function :math:`g` in Eq. :eq:`noepistasis`.</span>

<span class="sd">        Concrete implementation of :meth:`AbstractEpistasis.epistasis_func`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">latent_phenotype</span></div>

    <span class="k">def</span> <span class="nf">_depistasis_func_dlatent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_phenotype</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative of `epistasis_func` by latent phenotype.</span>

<span class="sd">        Concrete implementation of</span>
<span class="sd">        :meth:`AbstractEpistasis._depistasis_func_dlatent`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">latent_phenotype</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dloglik_depistasis_func_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements :meth:`AbstractEpistasis._dloglik_depistasis_func_params`</span>

<span class="sd">        For :class:`NoEpistasis` models, this is just an empty array as there</span>
<span class="sd">        are no epistasis function parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func_params_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Epistasis function parameter names.</span>

<span class="sd">        For :class:`NoEpistasis`, this is just an empty list as there are</span>
<span class="sd">        no epistasis function parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list: Bounds for the epistasis function parameters.</span>

<span class="sd">        For :class:`NoEpistasis` models, this is just an empty list as</span>
<span class="sd">        there are no epistasis function parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds_d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">bounds_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_prescale_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">g_k_range</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do nothing, as no need to prescale for :class:`NoEpistasis`.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_postscale_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If `_zero_wt_observed_pheno`, all wildtype latent -&gt; 0.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_wt_observed_pheno</span><span class="p">:</span>
            <span class="n">rescaled_latenteffects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">oldloglik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglik</span>
            <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">):</span>
                <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">rescaled_latenteffects</span>
            <span class="c1"># make sure log likelihood hasn&#39;t changed too much</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglik</span><span class="p">,</span> <span class="n">oldloglik</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">EpistasisFittingError</span><span class="p">(</span>
                    <span class="s2">&quot;post-scaling changed loglik &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">oldloglik</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loglik</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes_frombinary</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span><span class="p">)),</span> <span class="s2">&quot;observed&quot;</span>
                <span class="p">),</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="MonotonicSplineEpistasis"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.MonotonicSplineEpistasis">[docs]</a><span class="k">class</span> <span class="nc">MonotonicSplineEpistasis</span><span class="p">(</span><span class="n">AbstractEpistasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Monotonic spline global epistasis model.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Subclass of :class:`AbstractEpistasis` that implements the</span>
<span class="sd">    :ref:`monotonic_spline_epistasis_function`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spline_order : int</span>
<span class="sd">        Order of the I-splines defining the global epistasis function.</span>
<span class="sd">    meshpoints : int</span>
<span class="sd">        Number of evenly spaced mesh points for the I-spline defining the</span>
<span class="sd">        global epistasis function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">binarymap</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">model_one_less_latent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">spline_order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">meshpoints</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class docstring.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">meshpoints</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">meshpoints</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`meshpoints` must be int &gt; 1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">meshpoints</span><span class="p">),</span> <span class="n">n_latent_phenotypes</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_latent_phenotypes</span><span class="p">,</span> <span class="n">meshpoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spline_order</span> <span class="o">=</span> <span class="n">spline_order</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">binarymap</span><span class="p">,</span>
            <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="n">model_one_less_latent</span><span class="o">=</span><span class="n">model_one_less_latent</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_lower_latent_phenotype_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_one_less_latent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overrides :meth:`AbstractEpistasis._set_lower_latent_phenotypes`.</span>

<span class="sd">        Augments that base method to also set mesh.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_lower_latent_phenotype_params</span><span class="p">(</span><span class="n">model_one_less_latent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">):</span>
            <span class="n">ki</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_one_less_latent</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_isplines_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I-splines for global epistasis function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Which global epistasis function to get I-splines for (1 &lt;= k &lt;=</span>
<span class="sd">            :attr:`AbstractEpistasis.n_latent_phenotypes`). If there</span>
<span class="sd">            is just one latent phenotype, can also be `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`dms_variants.ispline.Isplines_total`</span>
<span class="sd">            The I-spline family defined with the current values of</span>
<span class="sd">            the latent phenotypes as `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_isplines_total_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dms_variants</span><span class="o">.</span><span class="n">ispline</span><span class="o">.</span><span class="n">Isplines_total</span><span class="p">(</span>
                <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spline_order</span><span class="p">,</span>
                <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="MonotonicSplineEpistasis.epistasis_func"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.MonotonicSplineEpistasis.epistasis_func">[docs]</a>    <span class="k">def</span> <span class="nf">epistasis_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_phenotype</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Global epistasis function :math:`g` in Eq. :eq:`monotonicspline`.</span>

<span class="sd">        Concrete implementation of :meth:`AbstractEpistasis.epistasis_func`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">latent_phenotype</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`latent_phenotype` not numpy array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">latent_phenotype</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">latent_phenotype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">Itotal</span><span class="p">(</span>
                <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_ms</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">w_lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_alpha</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dms_variants</span><span class="o">.</span><span class="n">ispline</span><span class="o">.</span><span class="n">Isplines_total</span><span class="p">(</span>
                <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spline_order</span><span class="p">,</span>
                <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)],</span>
                <span class="n">x</span><span class="o">=</span><span class="n">latent_phenotype</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">Itotal</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_ms</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">w_lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_alpha</span><span class="p">(</span><span class="n">k</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_depistasis_func_dlatent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_phenotype</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative of `epistasis_func` by latent phenotype.</span>

<span class="sd">        Concrete implementation of</span>
<span class="sd">        :meth:`AbstractEpistasis._depistasis_func_dlatent`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">dItotal_dx</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_ms</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_dloglik_depistasis_func_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements :meth:`AbstractEpistasis._dloglik_depistasis_func_params`</span>

<span class="sd">        See Eqs. :eq:`dspline_epistasis_dcalpha` and</span>
<span class="sd">        :eq:`dspline_epistasis_dalpham`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ki</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="p">[</span><span class="n">ki</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_alpha</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="p">[</span><span class="n">ki</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_ms</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="n">dcalpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_dobserved_phenotype</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">dItotal_dw_lower</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">dalpham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dloglik_dobserved_phenotype</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">dItotal_dweights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_ms</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_alpha</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">deriv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dcalpha</span><span class="p">,</span> <span class="n">dalpham</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">deriv</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">),)</span>
        <span class="k">return</span> <span class="n">deriv</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;list: Epistasis function parameter names.</span>

<span class="sd">        These are the :math:`c_{\alpha}` and :math:`\alpha_m` parameters</span>
<span class="sd">        in Eq. :eq:`monotonicspline`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;c_alpha&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;alpha_</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_epistasis_func_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;list: Bounds for the epistasis function parameters.</span>

<span class="sd">        There is no bound on :math:`c_{\alpha}`, and the :math:`\alpha_m`</span>
<span class="sd">        parameters must be &gt; 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds_d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;c_alpha&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">bounds_d</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;alpha_</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">bounds_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">]</span>

<div class="viewcode-block" id="MonotonicSplineEpistasis.c_alpha"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.MonotonicSplineEpistasis.c_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">c_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`c_{\alpha}` in Eq. :eq:`monotonicspline`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Which global epistasis function to get I-splines for (1 &lt;= k &lt;=</span>
<span class="sd">            :attr:`AbstractEpistasis.n_latent_phenotypes`). If there</span>
<span class="sd">            is just one latent phenotype, can also be `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            :math:`c_{\alpha}` for global epistasis function `k`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func_params_dict</span><span class="p">[</span><span class="s2">&quot;c_alpha&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func_params_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;c_alpha_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="MonotonicSplineEpistasis.alpha_ms"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.MonotonicSplineEpistasis.alpha_ms">[docs]</a>    <span class="k">def</span> <span class="nf">alpha_ms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`\alpha_m` in Eq. :eq:`monotonicspline`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or None</span>
<span class="sd">            Which global epistasis function to get I-splines for (1 &lt;= k &lt;=</span>
<span class="sd">            :attr:`AbstractEpistasis.n_latent_phenotypes`). If there</span>
<span class="sd">            is just one latent phenotype, can also be `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            :math:`\alpha_m` values for global epistasis function `k`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func_params_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;alpha_</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_latent_phenotype_k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func_params_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;alpha_</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">,</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_prescale_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">g_k_range</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get latent phenotypes in mesh and :math:`g_k` with desired limits.</span>

<span class="sd">        See :meth:`AbstractEpistasis._prescale_params` for description of</span>
<span class="sd">        parameters.</span>

<span class="sd">        Specifically, if `k == 1` then the latent phenotypes are re-scaled</span>
<span class="sd">        to span the mesh. The parameters of the global epistasis function</span>
<span class="sd">        :math:`g_k` are set so that :math:`c_alpha` is :math:`g_k_range[0]`,</span>
<span class="sd">        and all :math:`\alpha_m` values are set to</span>
<span class="sd">        :math:`\left[\max\left(y_v\right) - \min\left(y_v\right)\right] / M`</span>
<span class="sd">        so that the range of :math:`g_k` over its mesh spans `g_k_range`.</span>

<span class="sd">        If `k &gt; 1`, then the latent effects are all zero, the latent phenotype</span>
<span class="sd">        of wildtype is chosen so that :math:`g_k = 0` for wildtype, and</span>
<span class="sd">        the parameters of :math:`g_k` are chosen so that the limits on the</span>
<span class="sd">        mesh are `g_k_range` and all :math:`\alpha_m` values are equal.</span>
<span class="sd">        In addition, we require that `g_k_range[0] = -g_k_range[1]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `k` of </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ki</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># check g_k_range, and make sure &gt; 0</span>
        <span class="k">if</span> <span class="n">g_k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">g_k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid `g_k_range`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g_k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">g_k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">:</span>
            <span class="n">g_k_range</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">g_k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">,</span>
                <span class="n">g_k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># set initial epistasis func params</span>
        <span class="n">g_k_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">g_k_params</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">init_d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;c_alpha&quot;</span><span class="p">:</span> <span class="n">g_k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">init_d</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;alpha_</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">g_k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isplines_total</span><span class="p">(</span>
                <span class="n">k</span>
            <span class="p">)</span><span class="o">.</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">iparam</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="p">):</span>
            <span class="n">g_k_params</span><span class="p">[</span><span class="n">ki</span><span class="p">,</span> <span class="n">iparam</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_d</span><span class="p">[</span><span class="n">param</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span> <span class="o">=</span> <span class="n">g_k_params</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rescale_min</span><span class="p">,</span> <span class="n">rescale_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
            <span class="n">rescalerange</span> <span class="o">=</span> <span class="n">rescale_max</span> <span class="o">-</span> <span class="n">rescale_min</span>
            <span class="k">assert</span> <span class="n">rescalerange</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span>

            <span class="n">rescaled_latenteffects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">currentrange</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">currentrange</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;range of latent phenotype </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> is nearly zero &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">currentrange</span><span class="si">}</span><span class="s2">); so cannot pre-scale. Just &quot;</span>
                    <span class="s2">&quot;setting all latent effects to zero&quot;</span><span class="p">,</span>
                    <span class="n">EpistasisFittingWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">(</span>
                        <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">rescale_min</span>
                        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">rescaled_latenteffects</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># rescale so latent phenotypes span desired range</span>
                <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">*</span> <span class="n">rescalerange</span> <span class="o">/</span> <span class="n">currentrange</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">rescaled_latenteffects</span>
                <span class="c1"># change wt latent phenotype so latent phenos have right min</span>
                <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">(</span>
                        <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">rescale_min</span>
                        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">rescaled_latenteffects</span>

                <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">rescale_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">rescale_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                    <span class="n">rescalerange</span><span class="p">,</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latent_phenotypes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="p">),</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g_k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">g_k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`g_k_range` not symmetric: </span><span class="si">{</span><span class="n">g_k_range</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span>

            <span class="c1"># midpoint of mesh, g_k should be 0 here, set to wildtype latent k</span>
            <span class="n">mid_mesh</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mid_mesh</span><span class="p">]),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">))</span>
            <span class="n">latenteffects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">latenteffects</span>
            <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_phenotypes</span><span class="p">([</span><span class="n">k</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_postscale_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rescale parameters after global epistasis fitting.</span>

<span class="sd">        The parameters are re-scaled so that:</span>
<span class="sd">          - The mean absolute value latent effect is 1.</span>
<span class="sd">          - The latent phenotype of wildtype is 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rescaled_latenteffects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">oldloglik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglik</span>
        <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">):</span>
            <span class="c1"># make mean absolute latent effect equal to one</span>
            <span class="n">mean_abs_latent_effect</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mean_abs_latent_effect</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEARLY_ZERO</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;mean latent effect for phenotype </span><span class="si">{</span><span class="n">ki</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;is nearly zero (</span><span class="si">{</span><span class="n">mean_abs_latent_effect</span><span class="si">}</span><span class="s2">); &quot;</span>
                    <span class="s2">&quot;so cannot rescale&quot;</span><span class="p">,</span>
                    <span class="n">EpistasisFittingWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">/</span> <span class="n">mean_abs_latent_effect</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">/</span> <span class="n">mean_abs_latent_effect</span>

            <span class="c1"># make latent phenotype of wildtype equal to 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">-</span> <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">rescaled_latenteffects</span><span class="p">[</span><span class="n">ki</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_latenteffects</span> <span class="o">=</span> <span class="n">rescaled_latenteffects</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="mi">0</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_phenotype_wt</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># make sure log likelihood hasn&#39;t changed too much</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglik</span><span class="p">,</span> <span class="n">oldloglik</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">EpistasisFittingError</span><span class="p">(</span>
                <span class="s2">&quot;post-scaling latent effects changed &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;loglik </span><span class="si">{</span><span class="n">oldloglik</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loglik</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_wt_observed_pheno</span><span class="p">:</span>
            <span class="n">rescaled_func_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">c_alpha_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;c_alpha&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">ki</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">wt_obs_pheno_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistasis_func</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_phenotype_wt</span><span class="p">(</span><span class="n">k</span><span class="p">)]),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rescaled_func_params</span><span class="p">[</span><span class="n">ki</span><span class="p">,</span> <span class="n">c_alpha_index</span><span class="p">]</span> <span class="o">-=</span> <span class="n">wt_obs_pheno_k</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_epistasis_func_params</span> <span class="o">=</span> <span class="n">rescaled_func_params</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglik</span><span class="p">,</span> <span class="n">oldloglik</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">EpistasisFittingError</span><span class="p">(</span>
                    <span class="s2">&quot;post-scaling wt observed pheno changed likelihood&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; from loglik </span><span class="si">{</span><span class="n">oldloglik</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loglik</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes_frombinary</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_latent_effects</span><span class="p">)),</span> <span class="s2">&quot;observed&quot;</span>
                <span class="p">),</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="MonotonicSplineEpistasisGaussianLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.MonotonicSplineEpistasisGaussianLikelihood">[docs]</a><span class="k">class</span> <span class="nc">MonotonicSplineEpistasisGaussianLikelihood</span><span class="p">(</span>
    <span class="n">MonotonicSplineEpistasis</span><span class="p">,</span> <span class="n">GaussianLikelihood</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Monotonic spline global epistasis model with Gaussian likelihood.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implements the :ref:`monotonic_spline_epistasis_function`</span>
<span class="sd">    with a :ref:`gaussian_likelihood`. See documentation for the base</span>
<span class="sd">    classes :class:`MonotonicSplineEpistasis`, :class:`GaussianLikelihood`,</span>
<span class="sd">    and :class:`AbstractEpistasis` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="MonotonicSplineEpistasisCauchyLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.MonotonicSplineEpistasisCauchyLikelihood">[docs]</a><span class="k">class</span> <span class="nc">MonotonicSplineEpistasisCauchyLikelihood</span><span class="p">(</span>
    <span class="n">MonotonicSplineEpistasis</span><span class="p">,</span> <span class="n">CauchyLikelihood</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Monotonic spline global epistasis model with Cauchy likelihood.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implements the :ref:`monotonic_spline_epistasis_function`</span>
<span class="sd">    with a :ref:`cauchy_likelihood`. See documentation for the base</span>
<span class="sd">    classes :class:`MonotonicSplineEpistasis`, :class:`CauchyLikelihood`,</span>
<span class="sd">    and :class:`AbstractEpistasis` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="MonotonicSplineEpistasisBottleneckLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.MonotonicSplineEpistasisBottleneckLikelihood">[docs]</a><span class="k">class</span> <span class="nc">MonotonicSplineEpistasisBottleneckLikelihood</span><span class="p">(</span>
    <span class="n">MonotonicSplineEpistasis</span><span class="p">,</span> <span class="n">BottleneckLikelihood</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Monotonic spline global epistasis model with bottleneck likelihood.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implements the :ref:`monotonic_spline_epistasis_function`</span>
<span class="sd">    with a :ref:`bottleneck_likelihood`. See documentation for the base</span>
<span class="sd">    classes :class:`MonotonicSplineEpistasis`, :class:`BottleneckLikelihood`,</span>
<span class="sd">    and :class:`AbstractEpistasis` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">binarymap</span><span class="p">,</span>
        <span class="n">bottleneck</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">model_one_less_latent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">spline_order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">meshpoints</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">pseudocount</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class docstring.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">binarymap</span><span class="p">,</span>
            <span class="n">bottleneck</span><span class="o">=</span><span class="n">bottleneck</span><span class="p">,</span>
            <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="n">model_one_less_latent</span><span class="o">=</span><span class="n">model_one_less_latent</span><span class="p">,</span>
            <span class="n">spline_order</span><span class="o">=</span><span class="n">spline_order</span><span class="p">,</span>
            <span class="n">meshpoints</span><span class="o">=</span><span class="n">meshpoints</span><span class="p">,</span>
            <span class="n">pseudocount</span><span class="o">=</span><span class="n">pseudocount</span><span class="p">,</span>
            <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="NoEpistasisGaussianLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.NoEpistasisGaussianLikelihood">[docs]</a><span class="k">class</span> <span class="nc">NoEpistasisGaussianLikelihood</span><span class="p">(</span><span class="n">NoEpistasis</span><span class="p">,</span> <span class="n">GaussianLikelihood</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;No-epistasis model with Gaussian likelihood.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implements the :ref:`no_epistasis_function` with a</span>
<span class="sd">    :ref:`gaussian_likelihood`. See documentation for the base classes</span>
<span class="sd">    :class:`NoEpistasis`, :class:`GaussianLikelihood`, and</span>
<span class="sd">    :class:`AbstractEpistasis` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="NoEpistasisCauchyLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.NoEpistasisCauchyLikelihood">[docs]</a><span class="k">class</span> <span class="nc">NoEpistasisCauchyLikelihood</span><span class="p">(</span><span class="n">NoEpistasis</span><span class="p">,</span> <span class="n">CauchyLikelihood</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;No-epistasis model with Cauchy likelihood.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implements the :ref:`no_epistasis_function` with a</span>
<span class="sd">    :ref:`cauchy_likelihood`. See documentation for the base classes</span>
<span class="sd">    :class:`NoEpistasis`, :class:`CauchyLikelihood`, and</span>
<span class="sd">    :class:`AbstractEpistasis` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="NoEpistasisBottleneckLikelihood"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.NoEpistasisBottleneckLikelihood">[docs]</a><span class="k">class</span> <span class="nc">NoEpistasisBottleneckLikelihood</span><span class="p">(</span><span class="n">NoEpistasis</span><span class="p">,</span> <span class="n">BottleneckLikelihood</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;No-epistasis model with bottleneck likelihood.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implements the :ref:`no_epistasis_function` with a</span>
<span class="sd">    :ref:`bottleneck_likelihood`. See documentation for the base classes</span>
<span class="sd">    :class:`NoEpistasis`, :class:`BottleneckLikelihood`, and</span>
<span class="sd">    :class:`AbstractEpistasis` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="fit_models"><a class="viewcode-back" href="../../dms_variants.globalepistasis.html#dms_variants.globalepistasis.fit_models">[docs]</a><span class="k">def</span> <span class="nf">fit_models</span><span class="p">(</span>
    <span class="n">binarymap</span><span class="p">,</span>
    <span class="n">likelihood</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bottleneck</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_latent_phenotypes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fit and compare global epistasis models.</span>

<span class="sd">    This function is useful when you want to examine the fit of several</span>
<span class="sd">    different models to the same data. It does the following:</span>

<span class="sd">     1. Fits a non-epistatic model to the data.</span>

<span class="sd">     2. Fits a global epistasis model with :math:`K = 1` latent phenotypes</span>
<span class="sd">        to the data. If the global epistasis model outperforms the no-</span>
<span class="sd">        epistasis model by AIC_, proceed to next step. Otherwise stop.</span>

<span class="sd">     3. Fit a global epistasis model with :math:`K = 2` latent phenotypes.</span>
<span class="sd">        If this model outperforms (by AIC_) the model with :math:`K - 1`</span>
<span class="sd">        latent phenotypes, repeat for :math:`K = 3` etc until adding more</span>
<span class="sd">        latent phenotypes no longer improves fit. Note that it only does</span>
<span class="sd">        continues this process while :math:`K \le` `max_latent_phenotypes`,</span>
<span class="sd">        so set `max_latent_phenotypes` &gt; 1 if you want to fit multiple</span>
<span class="sd">        latent phenotypes.</span>

<span class="sd">    .. _AIC: https://en.wikipedia.org/wiki/Akaike_information_criterion</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    All of the fitting is done with the same likelihood-calculation method</span>
<span class="sd">    because you can **not** compare models fit with different likelihood-</span>
<span class="sd">    calculation methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binarymap : `BinaryMap &lt;https://github.com/jbloomlab/binarymap&gt;`_</span>
<span class="sd">        Contains the variants, their functional scores, and score variances.</span>
<span class="sd">        The models are fit to these data.</span>
<span class="sd">    likelihood : {&#39;Gaussian&#39;, &#39;Cauchy&#39;, &#39;Bottleneck&#39;}</span>
<span class="sd">        Likelihood calculation method to use when fitting models. See</span>
<span class="sd">        :ref:`likelihood_calculation`.</span>
<span class="sd">    bottleneck : float or None</span>
<span class="sd">        Required if using &#39;Bottleneck&#39; `likelihood`. In that case, is</span>
<span class="sd">        the experimentally estimated bottleneck between the pre-</span>
<span class="sd">        and post-selection conditions.</span>
<span class="sd">    max_latent_phenotypes : int</span>
<span class="sd">        Maximum number of latent phenotypes that are potentially be fit.</span>
<span class="sd">        See the :math:`K` parameter in :ref:`multi_latent`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        Summarizes the results of the model fitting and contains the</span>
<span class="sd">        fit models. Columns are:</span>

<span class="sd">          - &#39;description&#39;: description of model</span>
<span class="sd">          - &#39;n_latent_phenotypes&#39;: number of latent phenotypes in model</span>
<span class="sd">          - &#39;AIC&#39;: AIC_</span>
<span class="sd">          - &#39;nparams&#39;: number of parameters</span>
<span class="sd">          - &#39;log_likelihood&#39;: log likelihood</span>
<span class="sd">          - &#39;model&#39;: the actual model (subclass of :class:`AbstractEpistasis`)</span>
<span class="sd">          - &#39;fitting_time&#39;: time in seconds that it took to fit model</span>

<span class="sd">        The data frame is sorted from best to worst model by AIC_.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">max_latent_phenotypes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">max_latent_phenotypes</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`max_latent_phenotypes` must be int &gt;= 1&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">likelihood</span> <span class="o">==</span> <span class="s2">&quot;Gaussian&quot;</span><span class="p">:</span>
        <span class="n">NoEpistasisClass</span> <span class="o">=</span> <span class="n">NoEpistasisGaussianLikelihood</span>
        <span class="n">EpistasisClass</span> <span class="o">=</span> <span class="n">MonotonicSplineEpistasisGaussianLikelihood</span>
        <span class="n">bottleneck_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="n">likelihood</span> <span class="o">==</span> <span class="s2">&quot;Cauchy&quot;</span><span class="p">:</span>
        <span class="n">NoEpistasisClass</span> <span class="o">=</span> <span class="n">NoEpistasisCauchyLikelihood</span>
        <span class="n">EpistasisClass</span> <span class="o">=</span> <span class="n">MonotonicSplineEpistasisCauchyLikelihood</span>
        <span class="n">bottleneck_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="n">likelihood</span> <span class="o">==</span> <span class="s2">&quot;Bottleneck&quot;</span><span class="p">:</span>
        <span class="n">NoEpistasisClass</span> <span class="o">=</span> <span class="n">NoEpistasisBottleneckLikelihood</span>
        <span class="n">EpistasisClass</span> <span class="o">=</span> <span class="n">MonotonicSplineEpistasisBottleneckLikelihood</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bottleneck</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;specify `bottleneck` for Bottleneck likelihood&quot;</span><span class="p">)</span>
        <span class="n">bottleneck_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;bottleneck&quot;</span><span class="p">:</span> <span class="n">bottleneck</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `likelihood` </span><span class="si">{</span><span class="n">likelihood</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">FitData</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;FitData&quot;</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="s2">&quot;description&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n_latent_phenotypes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;AIC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nparams&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_likelihood&quot;</span><span class="p">,</span>
            <span class="s2">&quot;model&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fitting_time&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="n">modelclass</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">model_one_less_latent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">modelclass</span><span class="p">(</span>
            <span class="n">binarymap</span><span class="p">,</span>
            <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">model_one_less_latent</span><span class="o">=</span><span class="n">model_one_less_latent</span><span class="p">,</span>
            <span class="o">**</span><span class="n">bottleneck_args</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">FitData</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
            <span class="n">n_latent_phenotypes</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">n_latent_phenotypes</span><span class="p">,</span>
            <span class="n">AIC</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">aic</span><span class="p">,</span>
            <span class="n">nparams</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">nparams</span><span class="p">,</span>
            <span class="n">log_likelihood</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">loglik</span><span class="p">,</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">fitting_time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">fitlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit</span><span class="p">(</span><span class="n">NoEpistasisClass</span><span class="p">,</span> <span class="s2">&quot;no epistasis&quot;</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_latent_phenotypes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">max_latent_phenotypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;global epistasis&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;global epistasis with </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> latent phenotypes&quot;</span>
        <span class="n">fitlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">fit</span><span class="p">(</span>
                <span class="n">EpistasisClass</span><span class="p">,</span>
                <span class="n">description</span><span class="p">,</span>
                <span class="n">k</span><span class="p">,</span>
                <span class="n">model_one_less_latent</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">fitlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">fitlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AIC</span> <span class="o">&gt;</span> <span class="n">fitlist</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">AIC</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">fitlist</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">FitData</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;AIC&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/BloomLogo.jpg" alt="Logo"/>
    
    <h1 class="logo logo-name">dms_variants</h1>
    
  </a>
</p>



<p class="blurb">Analyze deep mutational scanning of barcoded variants</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=jbloomlab&repo=dms_variants&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">dms_variants documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dms_variants.html">dms_variants package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../package_index.html">package index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgments.html">Acknowledgements</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019--2022.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/jbloomlab/dms_variants" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>